<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.1 20151215//EN" "JATS-archivearticle1.dtd"> 
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article"><?properties open_access?><?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.1 20151215//EN?><?DTDIdentifier.IdentifierType public?><?SourceDTD.DTDName JATS-archivearticle1.dtd?><?SourceDTD.Version 1.1?><?ConverterInfo.XSLTName jp2nlmx2.xsl?><?ConverterInfo.Version 1?><front><journal-meta><journal-id journal-id-type="nlm-ta">PLoS Comput Biol</journal-id><journal-id journal-id-type="iso-abbrev">PLoS Comput. Biol</journal-id><journal-id journal-id-type="publisher-id">plos</journal-id><journal-id journal-id-type="pmc">ploscomp</journal-id><journal-title-group><journal-title>PLoS Computational Biology</journal-title></journal-title-group><issn pub-type="ppub">1553-734X</issn><issn pub-type="epub">1553-7358</issn><publisher><publisher-name>Public Library of Science</publisher-name><publisher-loc>San Francisco, CA USA</publisher-loc></publisher></journal-meta><article-meta><article-id pub-id-type="pmcid">4388847</article-id><article-id pub-id-type="pmid">25849257</article-id><article-id pub-id-type="publisher-id">PCOMPBIOL-D-14-00559</article-id><article-id pub-id-type="doi">10.1371/journal.pcbi.1004074</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research Article</subject></subj-group></article-categories><title-group><article-title>Machine Learning Assisted Design of Highly Active Peptides for Drug Discovery</article-title><alt-title alt-title-type="running-head">Machine Learning Assisted Design of Highly Active Peptides</alt-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>Gigu&#x000e8;re</surname><given-names>S&#x000e9;bastien</given-names></name><xref ref-type="aff" rid="aff001">
<sup>1</sup>
</xref><xref ref-type="corresp" rid="cor001">*</xref></contrib><contrib contrib-type="author"><name><surname>Laviolette</surname><given-names>Fran&#x000e7;ois</given-names></name><xref ref-type="aff" rid="aff001">
<sup>1</sup>
</xref></contrib><contrib contrib-type="author"><name><surname>Marchand</surname><given-names>Mario</given-names></name><xref ref-type="aff" rid="aff001">
<sup>1</sup>
</xref></contrib><contrib contrib-type="author"><name><surname>Tremblay</surname><given-names>Denise</given-names></name><xref ref-type="aff" rid="aff002">
<sup>2</sup>
</xref></contrib><contrib contrib-type="author"><name><surname>Moineau</surname><given-names>Sylvain</given-names></name><xref ref-type="aff" rid="aff002">
<sup>2</sup>
</xref></contrib><contrib contrib-type="author"><name><surname>Liang</surname><given-names>Xinxia</given-names></name><xref ref-type="aff" rid="aff003">
<sup>3</sup>
</xref></contrib><contrib contrib-type="author"><name><surname>Biron</surname><given-names>&#x000c9;ric</given-names></name><xref ref-type="aff" rid="aff003">
<sup>3</sup>
</xref></contrib><contrib contrib-type="author"><name><surname>Corbeil</surname><given-names>Jacques</given-names></name><xref ref-type="aff" rid="aff004">
<sup>4</sup>
</xref></contrib></contrib-group><aff id="aff001">
<label>1</label>
<addr-line>Department of Computer Science and Software Engineering, Universit&#x000e9; Laval, Qu&#x000e9;bec, Canada</addr-line>
</aff><aff id="aff002">
<label>2</label>
<addr-line>Department of Biochemistry, Microbiology and Bioinformatics, Universit&#x000e9; Laval, Qu&#x000e9;bec, Canada</addr-line>
</aff><aff id="aff003">
<label>3</label>
<addr-line>Faculty of Pharmacy, Universit&#x000e9; Laval, Qu&#x000e9;bec, Canada</addr-line>
</aff><aff id="aff004">
<label>4</label>
<addr-line>Department of Molecular Medicine, Universit&#x000e9; Laval, Qu&#x000e9;bec, Canada</addr-line>
</aff><contrib-group><contrib contrib-type="editor"><name><surname>Kim</surname><given-names>Philip M.</given-names></name><role>Editor</role><xref ref-type="aff" rid="edit1"/></contrib></contrib-group><aff id="edit1">
<addr-line>University of Toronto, CANADA</addr-line>
</aff><author-notes><fn fn-type="COI-statement" id="coi001"><p>The authors have declared that no competing interests exist.</p></fn><fn fn-type="con" id="contrib001"><p>Conceived and designed the experiments: SG FL MM DT SM EB XL JC. Performed the experiments: SG FL MM DT SM EB XL JC. Analyzed the data: SG FL MM DT SM EB XL JC. Contributed reagents/materials/analysis tools: SG FL MM DT SM EB XL JC. Wrote the paper: SG FL MM DT SM EB XL JC.</p></fn><corresp id="cor001">* E-mail: <email>sebastien.giguere.8@ulaval.ca</email></corresp></author-notes><pub-date pub-type="collection"><month>4</month><year>2015</year></pub-date><pub-date pub-type="epub"><day>7</day><month>4</month><year>2015</year></pub-date><volume>11</volume><issue>4</issue><elocation-id>e1004074</elocation-id><history><date date-type="received"><day>31</day><month>3</month><year>2014</year></date><date date-type="accepted"><day>5</day><month>12</month><year>2014</year></date></history><permissions><copyright-statement>&#x000a9; 2015 Gigu&#x000e8;re et al</copyright-statement><copyright-year>2015</copyright-year><copyright-holder>Gigu&#x000e8;re et al</copyright-holder><license xlink:href="http://creativecommons.org/licenses/by/4.0/"><license-p>This is an open-access article distributed under the terms of the Creative Commons Attribution License, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are properly credited.</license-p></license></permissions><self-uri content-type="pdf" xlink:type="simple" xlink:href="pcbi.1004074.pdf"/><abstract><p>The discovery of peptides possessing high biological activity is very challenging due to the enormous diversity for which only a minority have the desired properties. To lower cost and reduce the time to obtain promising peptides, machine learning approaches can greatly assist in the process and even partly replace expensive laboratory experiments by learning a predictor with existing data or with a smaller amount of data generation. Unfortunately, once the model is learned, selecting peptides having the greatest predicted bioactivity often requires a prohibitive amount of computational time. For this combinatorial problem, heuristics and stochastic optimization methods are not guaranteed to find adequate solutions. We focused on recent advances in kernel methods and machine learning to learn a predictive model with proven success. For this type of model, we propose an efficient algorithm based on graph theory, that is guaranteed to find the peptides for which the model predicts maximal bioactivity. We also present a second algorithm capable of sorting the peptides of maximal bioactivity. Extensive analyses demonstrate how these algorithms can be part of an iterative combinatorial chemistry procedure to speed up the discovery and the validation of peptide leads. Moreover, the proposed approach does not require the use of known ligands for the target protein since it can leverage recent multi-target machine learning predictors where ligands for similar targets can serve as initial training data. Finally, we validated the proposed approach in vitro with the discovery of new cationic antimicrobial peptides. Source code freely available at <ext-link ext-link-type="uri" xlink:href="http://graal.ift.ulaval.ca/peptide-design/">http://graal.ift.ulaval.ca/peptide-design/</ext-link>.</p></abstract><abstract abstract-type="summary"><title>Author Summary</title><p>Part of the complexity of drug discovery is the sheer chemical diversity to explore combined to all requirements a compound must meet to become a commercial drug. Hence, it makes sense to automate this chemical exploration endeavor in a wise, informed, and efficient fashion. Here, we focused on peptides as they have properties that make them excellent drug starting points. Machine learning techniques may replace expensive <italic>in-vitro</italic> laboratory experiments by learning an accurate model of it. However, computational models also suffer from the combinatorial explosion due to the enormous chemical diversity. Indeed, applying the model to every peptides would take an astronomical amount of computer time. Therefore, given a model, is it possible to determine, using reasonable computational time, the peptide that has the best properties and chance for success? This exact question is what motivated our work. We focused on recent advances in kernel methods and machine learning to learn a model that already had excellent results. We demonstrate that this class of model has mathematical properties that makes it possible to rapidly identify and sort the best peptides. Finally, <italic>in-vitro</italic> and <italic>in-silico</italic> results are provided to support and validate this theoretical discovery.</p></abstract><funding-group><funding-statement>This work was supported in part by the Fonds de recherche du Qu&#x000e9;bec (FRQNT) (FL, MM, EB &#x00026; JC; 2013-PR-166708), the Natural Sciences and Engineering Research Council (NSERC) Discovery Grants (FL; 262067, MM; 122405), and Compute Canada. SM holds a Tier 1 Canada Research Chair in Bacteriophages. XL thanks the China Schorlaship Council for postgraduate scholarships. EB thanks Fonds de recherche du Qu&#x000e9;bec&#x02014;Sant&#x000e9; (FRQS) for a Junior I Young Investigator Career Award. JC holds a Tier 1 Canada Research Chair in Medical Genomics. The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.</funding-statement></funding-group><counts><fig-count count="5"/><table-count count="2"/><page-count count="21"/></counts><custom-meta-group><custom-meta id="data-availability"><meta-name>Data Availability</meta-name><meta-value>All relevant data are within the paper and its Supporting Information files.</meta-value></custom-meta></custom-meta-group></article-meta><notes><title>Data Availability</title><p>All relevant data are within the paper and its Supporting Information files.</p></notes></front><body><sec sec-type="intro" id="sec001"><title>Introduction</title><p>Drug discovery faces important challenges in terms of cost, complexity and the amount of time required to yield promising compounds. To avoid side effects, a valuable drug precursor must have high affinity with the target protein while minimizing interactions with other proteins. Unfortunately, only a few have such properties and these have to be identified from an astronomical number of candidate compounds. Other factors, such as bioavailability and stability have to be considered; but this combinatorial search problem, by itself, is very challenging [<xref rid="pcbi.1004074.ref001" ref-type="bibr">1</xref>].</p><p>For novel and less studied targets, screening compound libraries remain the method of choice for rapid data generation. To fully exploit the great conformational and functional diversity, combinatorial peptide chemistry is certainly a powerful tool [<xref rid="pcbi.1004074.ref002" ref-type="bibr">2</xref>&#x02013;<xref rid="pcbi.1004074.ref004" ref-type="bibr">4</xref>]. A major advantage of using combinatorial peptide libraries over classic combinatorial libraries, where the scaffold is fixed, is the possibility of generating enormous conformational and functional diversity using a randomized synthesis procedure. This chemical diversity and functionality can be further enhanced by the inclusion of non-natural amino acids [<xref rid="pcbi.1004074.ref005" ref-type="bibr">5</xref>]. Furthermore, having a peptide scaffold can be very informative to screen for similarities in peptidomimetic libraries [<xref rid="pcbi.1004074.ref006" ref-type="bibr">6</xref>]. For these reasons, this work will focus on using peptides as drug precursors.</p><p>However, it is important to note that combinatorial peptide chemistry cannot cover a significant part of the peptide diversity when peptides are longer than a few amino acids. For example, 2<italic>g</italic> of a one-bead one-compound (OBOC) combinatorial library [<xref rid="pcbi.1004074.ref007" ref-type="bibr">7</xref>] composed of randomly-generated peptides of nine residues will generate a maximum of six million compounds, representing a vanishingly small fraction (less than 0.0016%) of the set of all 20<sup>9</sup> peptides. Consequently, it is almost certain that the best peptides will not be present and most synthesized peptides will have low bioactivity. Hence, drug discovery is a combinatorial problem which, unfortunately, cannot be solved using combinatorial chemistry alone. The process of discovering novel compounds with both high bioactivity and low toxicity must therefore be optimized.</p><p>Machine learning and kernel methods [<xref rid="pcbi.1004074.ref008" ref-type="bibr">8</xref>] have the potential to help with this endeavour. These algorithms are extremely effective at providing accurate models for a wide range of biological and chemical problems: anti-cancer activity of small molecules [<xref rid="pcbi.1004074.ref009" ref-type="bibr">9</xref>], protein-ligand interactions [<xref rid="pcbi.1004074.ref010" ref-type="bibr">10</xref>] and protein-protein interactions [<xref rid="pcbi.1004074.ref011" ref-type="bibr">11</xref>]. The inclusion of similarity functions, known as <italic>kernels</italic> [<xref rid="pcbi.1004074.ref008" ref-type="bibr">8</xref>], provides a novel way to find patterns in biological and chemical data. By incorporating valuable biological and chemical knowledge, kernels provide an efficient way to improve the accuracy of learning algorithms.</p><p>This work explores the use of learning algorithms to design and enhance the pharmaceutical properties of compounds [<xref rid="pcbi.1004074.ref012" ref-type="bibr">12</xref>, <xref rid="pcbi.1004074.ref013" ref-type="bibr">13</xref>]. By starting with a training set containing approximately 100 peptides with their corresponding validated bioactivity (binding affinity, IC<sub>50</sub>, etc), we expect that a state-of-the-art kernel method will give a bioactivity model which is sufficiently accurate to find new peptides with activities higher than the 100 used to learn the model. This is possible because each peptide that possesses a small binding affinity contains information about subsequences of residues that can bind to the target. Learning a model can accelerate, but not solve, this costly process. <italic>In-silico</italic> predictions are faster and cheaper than <italic>in-vitro</italic> assays, however, predicting the bioactivity of all possible peptide to select the most bioactive ones would require a prohibitive amount of computational time. Indeed, this transforms the combinatorial drug discovery problem into an equally hard computational task.</p><p>We demonstrate that for a large class of kernel based models, it is possible to design an efficient algorithm guaranteed to find the peptide of maximal predicted bioactivity. This algorithm makes use of graph theory and recent work [<xref rid="pcbi.1004074.ref014" ref-type="bibr">14</xref>] on the prediction of the bioactivity and the binding affinity between peptides and a target protein. This algorithm can be part of an iterative combinatorial chemistry procedure that could speed up the discovery and the validation of peptide leads. Moreover, the proposed approach can be employed without known ligands for the target protein because it can leverage recent multi-target machine learning predictors [<xref rid="pcbi.1004074.ref010" ref-type="bibr">10</xref>, <xref rid="pcbi.1004074.ref014" ref-type="bibr">14</xref>] where ligands for similar targets can serve as an initial training set. Finally, we demonstrate the effectiveness and validate our approach <italic>in vitro</italic> by providing an example of how antimicrobial peptides with proven activity were designed.</p></sec><sec sec-type="materials|methods" id="sec002"><title>Methods</title><sec id="sec002a"><title>The Generic String kernel</title><p>String kernels are symmetric positive semi-definite similarity functions between strings. In our context, strings are sequences of amino acids. Such kernels have been widely used in applications of machine learning to biology. For example, the local-alignment kernel [<xref rid="pcbi.1004074.ref015" ref-type="bibr">15</xref>], closely related to the well-known Smith-Waterman alignment algorithm, was used for protein homology detection. It was however observed that kernels for large molecules such as proteins were not suitable for smaller amino acid sequences such as peptides [<xref rid="pcbi.1004074.ref014" ref-type="bibr">14</xref>]. Indeed, the idea of gaps in the local-alignment kernel or in the Smith-Waterman algorithm is well suited for protein homology, but a gap of only a few amino acids in a peptide would have important consequences on its ability to bind with a target protein. Many recently proposed string kernels have emerged from the original idea of the spectrum kernel [<xref rid="pcbi.1004074.ref016" ref-type="bibr">16</xref>] where each string is represented by the set of all its constituent <italic>k</italic>-mers. For example, the string <italic>PALI</italic> can be represented by the set of 2-mers {<italic>PA, AL, LI</italic>}. As defined by the <italic>k</italic>-spectrum kernel, the similarity score between two strings is simply the number of <italic>k</italic>-mers that they have in common. For example, the 2-spectrum similarity between <italic>PALI</italic> and <italic>LIPAT</italic> is 2, because they have two 2-mers in common (<italic>PA</italic> and <italic>LI</italic>).</p><p>To characterize the similarity between peptides, two different <italic>k</italic>-mer criteria were found to be important. First, two <italic>k</italic>-mers should only contribute to the similarity if they are in similar positions in the two peptides [<xref rid="pcbi.1004074.ref017" ref-type="bibr">17</xref>]. Second, the two <italic>k</italic>-mers should share common physico-chemical properties [<xref rid="pcbi.1004074.ref018" ref-type="bibr">18</xref>].</p><p>Meinicke and colleagues [<xref rid="pcbi.1004074.ref017" ref-type="bibr">17</xref>] proposed to weight the contribution of identical <italic>k</italic>-mers with a term that decays exponentially with the distance between their positions. If <italic>i</italic> and <italic>j</italic> denote the positions of the <italic>k</italic>-mers in their respective strings, the contribution to the similarity is given by
<disp-formula id="pcbi.1004074.e001"><alternatives><graphic xlink:href="pcbi.1004074.e001.jpg" id="pcbi.1004074.e001g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M1"><mml:mrow><mml:mi>exp</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:msubsup><mml:mi>&#x003c3;</mml:mi><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives><label>(1)</label></disp-formula>
where <italic>&#x003c3;</italic>
<sub><italic>p</italic></sub> is a parameter that controls the length of the decay.</p><p>Toussaint and colleagues [<xref rid="pcbi.1004074.ref018" ref-type="bibr">18</xref>] proposed to consider properties of amino acids when comparing similar <italic>k</italic>-mers. This was motivated by the fact that amino acids with similar physico-chemical properties can be substituted in a peptide while maintaining the binding characteristics. To capture the physicochemical properties of amino acids, they proposed to use an encoding function <inline-formula id="pcbi.1004074.e002"><alternatives><graphic xlink:href="pcbi.1004074.e002.jpg" id="pcbi.1004074.e002g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M2"><mml:mrow><mml:mi mathvariant="bold">&#x003c8;</mml:mi><mml:mo>:</mml:mo><mml:mo>&#x1d4d0;</mml:mo><mml:mo>&#x02192;</mml:mo><mml:msup><mml:mi>&#x0211d;</mml:mi><mml:mi>d</mml:mi></mml:msup></mml:mrow></mml:math></alternatives></inline-formula> where <italic><bold>&#x003c8;</bold></italic>(<italic>a</italic>) = (<italic><bold>&#x003c8;</bold></italic>
<sub>1</sub>(<italic>a</italic>), <italic><bold>&#x003c8;</bold></italic>
<sub>2</sub>(<italic>a</italic>), &#x02026;, <italic><bold>&#x003c8;</bold></italic>
<sub><italic>d</italic></sub>(<italic>a</italic>)), to map every amino acid <inline-formula id="pcbi.1004074.e003"><alternatives><graphic xlink:href="pcbi.1004074.e003.jpg" id="pcbi.1004074.e003g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M3"><mml:mrow><mml:mi>a</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mo>&#x1d4d0;</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> to a vector where each component <italic><bold>&#x003c8;</bold></italic>
<sub><italic>i</italic></sub>(<italic>a</italic>) encodes one of the <italic>d</italic> properties of amino acid <italic>a</italic>. In a similar way, we can define <inline-formula id="pcbi.1004074.e004"><alternatives><graphic xlink:href="pcbi.1004074.e004.jpg" id="pcbi.1004074.e004g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M4"><mml:mrow><mml:msup><mml:mi mathvariant="bold">&#x003c8;</mml:mi><mml:mi>k</mml:mi></mml:msup><mml:mo>:</mml:mo><mml:msup><mml:mo>&#x1d4d0;</mml:mo><mml:mi>k</mml:mi></mml:msup><mml:mo>&#x02192;</mml:mo><mml:msup><mml:mi>&#x0211d;</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></alternatives></inline-formula> as an encoding function for <italic>k</italic>-mers, where
<disp-formula id="pcbi.1004074.e005"><alternatives><graphic xlink:href="pcbi.1004074.e005.jpg" id="pcbi.1004074.e005g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M5"><mml:mrow><mml:msup><mml:mi mathvariant="bold">&#x003c8;</mml:mi><mml:mi>k</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mover><mml:mo>=</mml:mo><mml:mtext>def</mml:mtext></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold">&#x003c8;</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi mathvariant="bold">&#x003c8;</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:mi mathvariant="bold">&#x003c8;</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives><label>(2)</label></disp-formula>
by concatenating <italic>k</italic> physico-chemical property vectors, each having <italic>d</italic> components. Throughout this study, the BLOSUM62 matrix was used in such a way that <italic><bold>&#x003c8;</bold></italic>(<italic>a</italic>) is the line associated to the amino acid <italic>a</italic> in the matrix. It is now possible to weight the contribution of any two <italic>k</italic>-mers <italic>a</italic>
<sub>1</sub>, &#x02026;, <italic>a</italic>
<sub><italic>k</italic></sub> and <inline-formula id="pcbi.1004074.e006"><alternatives><graphic xlink:href="pcbi.1004074.e006.jpg" id="pcbi.1004074.e006g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M6"><mml:mrow><mml:msub><mml:msup><mml:mi>a</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:msup><mml:mi>a</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula> according to their properties:
<disp-formula id="pcbi.1004074.e007"><alternatives><graphic xlink:href="pcbi.1004074.e007.jpg" id="pcbi.1004074.e007g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M7"><mml:mrow><mml:mi>exp</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mspace width="1pt"/><mml:mo>&#x02016;</mml:mo><mml:msup><mml:mi mathvariant="bold">&#x003c8;</mml:mi><mml:mi>k</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mspace width="1pt"/><mml:msup><mml:mi mathvariant="bold">&#x003c8;</mml:mi><mml:mi>k</mml:mi></mml:msup><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:msup><mml:mi>a</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:msup><mml:mi>a</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02016;</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:msubsup><mml:mi>&#x003c3;</mml:mi><mml:mi>c</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives><label>(3)</label></disp-formula>
where &#x02016;&#x02219;&#x02016; denotes the Euclidean distance.</p><p>More recently, the Generic String (GS) kernel was proposed for small biological sequences and pseudo-sequences of binding interfaces [<xref rid="pcbi.1004074.ref014" ref-type="bibr">14</xref>]. The GS kernel similarity between an arbitrary pair (<bold>x</bold>, <bold>x</bold>&#x02032;) of biological sequences is defined to be
<disp-formula id="pcbi.1004074.e008"><alternatives><graphic xlink:href="pcbi.1004074.e008.jpg" id="pcbi.1004074.e008g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M8"><mml:mrow><mml:mi>G</mml:mi><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>x</mml:mi></mml:mstyle><mml:mo>,</mml:mo><mml:msup><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>x</mml:mi></mml:mstyle><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003c3;</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003c3;</mml:mi><mml:mi>c</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mover><mml:mo>=</mml:mo><mml:mtext>def</mml:mtext></mml:mover><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>x</mml:mi><mml:mo>|</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mi>l</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:msup><mml:mi>x</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mo>|</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mi>l</mml:mi></mml:mrow></mml:munderover></mml:mstyle></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle><mml:mi>exp</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:msubsup><mml:mi>&#x003c3;</mml:mi><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mi>exp</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mspace width="1pt"/><mml:mo>&#x02016;</mml:mo><mml:msup><mml:mi mathvariant="bold">&#x003c8;</mml:mi><mml:mi>l</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mn>..</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02212;</mml:mo><mml:msup><mml:mi mathvariant="bold">&#x003c8;</mml:mi><mml:mi>l</mml:mi></mml:msup><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:msup><mml:mi>x</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mn>..</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02016;</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:msubsup><mml:mi>&#x003c3;</mml:mi><mml:mi>c</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></alternatives><label>(4)</label></disp-formula>
Hence, the GS similarity between strings <bold>x</bold> and <bold>x</bold>&#x02032;, is given by comparing their 1-mer, 2-mers, &#x02026;up to their <italic>k</italic>-mers, with the position penalizing term of <xref ref-type="disp-formula" rid="pcbi.1004074.e001">Equation (1)</xref> and the physico-chemical contribution term of <xref ref-type="disp-formula" rid="pcbi.1004074.e007">Equation (3)</xref>. The hyper-parameters <italic>k</italic>, <italic>&#x003c3;</italic>
<sub><italic>p</italic></sub>, <italic>&#x003c3;</italic>
<sub><italic>c</italic></sub> are chosen by cross-validation.</p><p>This GS kernel is very versatile since, depending on the chosen hyper-parameters, it can be specialized to eight known kernels [<xref rid="pcbi.1004074.ref014" ref-type="bibr">14</xref>]: the Hamming kernel, the Dirac delta, the Blended Spectrum [<xref rid="pcbi.1004074.ref008" ref-type="bibr">8</xref>], the Radial Basis Function (RBF), the Blended Spectrum RBF [<xref rid="pcbi.1004074.ref018" ref-type="bibr">18</xref>], the Oligo [<xref rid="pcbi.1004074.ref017" ref-type="bibr">17</xref>], the Weighted degree [<xref rid="pcbi.1004074.ref019" ref-type="bibr">19</xref>], and the Weighted degree RBF [<xref rid="pcbi.1004074.ref018" ref-type="bibr">18</xref>]. It thus follows that the proposed method, based on the GS kernel, is also valid for all of these kernels.</p><p>Recently [<xref rid="pcbi.1004074.ref014" ref-type="bibr">14</xref>], the GS kernel was used to learn a predictor capable of predicting, with reasonable accuracy, the binding affinity of any peptide to any protein on the PepX database. The GS kernel has also outperformed current state-of-the-art methods for predicting peptide-protein binding affinities on single-target and pan-specific Major Histocompatibility Complex (MHC) class II benchmark datasets and three Quantitative Structure Affinity Model benchmark datasets. The GS kernel was also part of a method that won the 2012 Machine Learning Competition in Immunology [<xref rid="pcbi.1004074.ref020" ref-type="bibr">20</xref>]. External validation showed that the SVM classifier with the GS kernel was the overall best method to identify, given unpublished experimental data, new peptides naturally processed by the MHC Class I pathway. The proven effectiveness of this kernel made it ideal to tackle the present problem.</p></sec><sec id="sec002b"><title>The machine learning approach</title><p>In the binary classification setting, the learning task is to predict whether a peptide has a specific property such as binding to a target molecule. In the regression setting, the learning task is to predict a real value that quantifies the quality of a peptide, for example, its bioactivity, inhibitory concentration, binding affinity, or bioavailability. In contrast to classification and regression, the task we consider here (described in the next section) is ultimately to predict a string of amino acids.</p><p>In this paper, each learning example ((<bold>x</bold>, <bold>y</bold>), <italic>e</italic>) consists of a peptide <bold>x</bold>, a drug target <bold>y</bold>, which is typically a protein (but other biomolecules could be considered), and a real number <italic>e</italic> representing the bioactivity of the peptide <bold>x</bold> with the target <bold>y</bold>. In classification, <italic>e</italic> &#x02208; {+1, &#x02212;1} denotes whether (<bold>x</bold>, <bold>y</bold>) has the desired property or not. Since predicting real values is strictly more general than predicting binary values, we focused on the more general case of real-valued predictors. Those learning examples are obtained from <italic>in vitro</italic> or <italic>in vivo</italic> experiments. The learning task is therefore to infer the value of <italic>e</italic> given new examples (<bold>x</bold>, <bold>y</bold>) that would not have been tested through experiments.</p><p>A predictor is a function <italic>h</italic> that returns an output <italic>h</italic>(<bold>x</bold>, <bold>y</bold>) when given any input (<bold>x</bold>, <bold>y</bold>). In our setting, the output <italic>h</italic>(<bold>x</bold>, <bold>y</bold>) is a real number that estimates the &#x0201c;true&#x0201d; bioactivity <italic>e</italic> between <bold>x</bold> and <bold>y</bold>. Such a predictor is said to be <italic>multi-target</italic> since its output depends on the ligand <bold>x</bold> and the target <bold>y</bold>. A multi-target predictor is generally obtained by learning from numerous peptides, binding to various proteins, for example, a protein family. For this reason, it can predict the bioactivity of any peptide with any protein of the family even if some proteins are not present in the training data [<xref rid="pcbi.1004074.ref010" ref-type="bibr">10</xref>, <xref rid="pcbi.1004074.ref014" ref-type="bibr">14</xref>].</p><p>In contrast, a predictor <italic>h</italic>
<sub><bold>y</bold></sub>(<bold>x</bold>) is said to be <italic>target-specific</italic> when it is dedicated to predict the bioactivity of any peptide <bold>x</bold> with a specific protein <bold>y</bold>. A target-specific predictor is obtained by learning only from peptides binding to a specific protein or from a multi-target predictor [<xref rid="pcbi.1004074.ref010" ref-type="bibr">10</xref>, <xref rid="pcbi.1004074.ref014" ref-type="bibr">14</xref>]. For simplicity, we will focus on target-specific predictor but let us demonstrate how a target-specific predictor is obtained from a multi-target one.</p><p>Given a training set {((<bold>x</bold>
<sub>1</sub>, <bold>y</bold>
<sub>1</sub>), <italic>e</italic>
<sub>1</sub>), &#x02026;, ((<bold>x</bold>
<sub><italic>m</italic></sub>, <bold>y</bold>
<sub><italic>m</italic></sub>), <italic>e</italic>
<sub><italic>m</italic></sub>)}, a large class of learning algorithms produce multi-target predictors <italic>h</italic> with the output <italic>h</italic>(<bold>x</bold>, <bold>y</bold>) on an arbitrary example (<bold>x</bold>, <bold>y</bold>) given by
<disp-formula id="pcbi.1004074.e009"><alternatives><graphic xlink:href="pcbi.1004074.e009.jpg" id="pcbi.1004074.e009g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M9"><mml:mrow><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>x</mml:mi></mml:mstyle><mml:mo>,</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>y</mml:mi></mml:mstyle><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>&#x003b1;</mml:mi><mml:mi>q</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:msub><mml:mi>k</mml:mi><mml:mo>&#x1d4e8;</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>y</mml:mi></mml:mstyle><mml:mo>,</mml:mo><mml:msub><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>y</mml:mi></mml:mstyle><mml:mi>q</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>k</mml:mi><mml:mo>&#x1d4e7;</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>x</mml:mi></mml:mstyle><mml:mo>,</mml:mo><mml:msub><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>x</mml:mi></mml:mstyle><mml:mi>q</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives><label>(5)</label></disp-formula>
where <inline-formula id="pcbi.1004074.e010"><alternatives><graphic xlink:href="pcbi.1004074.e010.jpg" id="pcbi.1004074.e010g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M10"><mml:mrow><mml:msub><mml:mi>k</mml:mi><mml:mo>&#x1d4e8;</mml:mo></mml:msub><mml:mo>:</mml:mo><mml:mo>&#x1d4e8;</mml:mo><mml:mo>&#x000d7;</mml:mo><mml:mo>&#x1d4e8;</mml:mo><mml:mo>&#x02192;</mml:mo><mml:mi>&#x0211d;</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1004074.e011"><alternatives><graphic xlink:href="pcbi.1004074.e011.jpg" id="pcbi.1004074.e011g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M11"><mml:mrow><mml:msub><mml:mi>k</mml:mi><mml:mo>&#x1d4e7;</mml:mo></mml:msub><mml:mo>:</mml:mo><mml:mo>&#x1d4e7;</mml:mo><mml:mo>&#x000d7;</mml:mo><mml:mo>&#x1d4e7;</mml:mo><mml:mo>&#x02192;</mml:mo><mml:mi>&#x0211d;</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> are, respectively, the kernel functions between proteins and peptides, and <italic>&#x003b1;</italic>
<sub><italic>q</italic></sub> is the weight on the <italic>q</italic>-th training example. Since we use the GS kernel for <inline-formula id="pcbi.1004074.e012"><alternatives><graphic xlink:href="pcbi.1004074.e012.jpg" id="pcbi.1004074.e012g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M12"><mml:mrow><mml:msub><mml:mi>k</mml:mi><mml:mo>&#x1d4e7;</mml:mo></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>, we obtain the target-specific predictor
<disp-formula id="pcbi.1004074.e013"><alternatives><graphic xlink:href="pcbi.1004074.e013.jpg" id="pcbi.1004074.e013g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M13"><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>y</mml:mi></mml:mstyle></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>x</mml:mi></mml:mstyle><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>&#x003b2;</mml:mi><mml:mi>q</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>y</mml:mi></mml:mstyle><mml:mo stretchy="false">)</mml:mo><mml:mi>G</mml:mi><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>x</mml:mi></mml:mstyle><mml:mo>,</mml:mo><mml:msub><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>x</mml:mi></mml:mstyle><mml:mi>q</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003c3;</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003c3;</mml:mi><mml:mi>c</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></alternatives><label>(6)</label></disp-formula>
Here the weight on the <italic>q</italic>-th training example is now given by <italic>&#x003b2;</italic>
<sub><italic>q</italic></sub>(<bold>y</bold>). To obtain <italic>h</italic>
<sub><bold>y</bold></sub> from a multi-target predictor, we use <inline-formula id="pcbi.1004074.e014"><alternatives><graphic xlink:href="pcbi.1004074.e014.jpg" id="pcbi.1004074.e014g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M14"><mml:mrow><mml:msub><mml:mi>&#x003b2;</mml:mi><mml:mi>q</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>y</mml:mi></mml:mstyle><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003b1;</mml:mi><mml:mi>q</mml:mi></mml:msub><mml:msub><mml:mi>k</mml:mi><mml:mo>&#x1d4e8;</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>y</mml:mi></mml:mstyle><mml:mo>,</mml:mo><mml:msub><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>y</mml:mi></mml:mstyle><mml:mi>q</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. When <italic>h</italic>
<sub><bold>y</bold></sub> is target-specific predictor learned only with peptides binding to <bold>y</bold>, we simply use <italic>&#x003b2;</italic>
<sub><italic>q</italic></sub>(<bold>y</bold>) = <italic>&#x003b1;</italic>
<sub><italic>q</italic></sub>. The remainder of this manuscript will focus on target-specific predictor in the form of <xref ref-type="disp-formula" rid="pcbi.1004074.e013">Equation 6</xref>. This makes the proposed solution compatible for both target-specific and multi-target predictors. Also, since the weights on examples are given by <italic>&#x003b2;</italic>(<bold>y</bold>), we will see that the approach is valid regardless of the choice of kernel for the target protein.</p><p>The weight vector <inline-formula id="pcbi.1004074.e015"><alternatives><graphic xlink:href="pcbi.1004074.e015.jpg" id="pcbi.1004074.e015g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M15"><mml:mrow><mml:mi mathvariant="bold">&#x003b1;</mml:mi><mml:mover><mml:mo>=</mml:mo><mml:mrow><mml:mtext>def</mml:mtext></mml:mrow></mml:mover><mml:mspace width="1pt"/><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>&#x003b1;</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003b1;</mml:mi><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> depends on the learning algorithm used, but many algorithms produce prediction functions given by <xref ref-type="disp-formula" rid="pcbi.1004074.e009">Equation (5)</xref>, including the Support Vector Machine, the Support Vector Regression, the Ridge Regression, and Gaussian Processes. Note that all these learning methods require both kernels to be symmetric and positive semi-definite. This is the case for the GS kernel. The proposed solution for drug design is thus compatible with these popular bioinformatics learning algorithms [<xref rid="pcbi.1004074.ref021" ref-type="bibr">21</xref>]. However, some machine learning methods such as neural networks and its derivatives (deep neural networks) are not compatible with the proposed methodology.</p><p>For the sake of comparison, we would like to highlight that when <italic>&#x003b2;</italic>
<sub><italic>q</italic></sub>(<bold>y</bold>) = 1/<italic>m</italic>, <italic>k</italic> = 1, <italic>&#x003c3;</italic>
<sub><italic>p</italic></sub> = 0, and <italic>&#x003c3;</italic>
<sub><italic>c</italic></sub> = 0 the predictor <italic>h</italic>
<sub><bold>y</bold></sub>(<bold>x</bold>) in <xref ref-type="disp-formula" rid="pcbi.1004074.e013">Equation (6)</xref> reduces to predict the probability of sequence <bold>x</bold> given the position-specific weight matrix (PSWM) obtained from the training set. Since <italic>&#x003b2;</italic>
<sub><italic>q</italic></sub>(<bold>y</bold>), <italic>k</italic>, <italic>&#x003c3;</italic>
<sub><italic>p</italic></sub>, and <italic>&#x003c3;</italic>
<sub><italic>c</italic></sub> can be arbitrary, the class of predictors we consider here is much more general.</p><p>Indeed, a PSWM consists of a position frequency matrix <inline-formula id="pcbi.1004074.e016"><alternatives><graphic xlink:href="pcbi.1004074.e016.jpg" id="pcbi.1004074.e016g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M16"><mml:mrow><mml:mi>M</mml:mi><mml:mo>:</mml:mo><mml:mspace width="1pt"/><mml:mo>|</mml:mo><mml:mo>&#x1d4d0;</mml:mo><mml:mo>|</mml:mo><mml:mo>&#x000d7;</mml:mo><mml:mspace width="1pt"/><mml:mi>l</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> where <italic>M</italic>
<sub><italic>i, j</italic></sub> denotes the frequency of the <italic>i</italic>-th amino acid at the <italic>j</italic>-th position of peptides in the dataset. Since a PSWM assumes statistical independence between positions in the pattern, the probability that a sequence belongs to a certain pattern is given by summing the corresponding entries in <italic>M</italic>. PSWM are simple but have, however, been surpassed by modern machine learning algorithms [<xref rid="pcbi.1004074.ref022" ref-type="bibr">22</xref>, <xref rid="pcbi.1004074.ref023" ref-type="bibr">23</xref>] since they assume independence between positions in the pattern. Moreover, they do not take into account the quantified bioactivity nor the similarities between amino acids. In addition, they require peptides to be aligned or of the same length. The method we present here have none of these serious limitations by allowing more sophisticated predictors to be learned.</p></sec><sec id="sec002c"><title>The combinatorial search problem</title><p>The main motivation for learning a predictor from training data is that, once an accurate predictor is obtained, finding druggable peptides would be greatly facilitated. It is true that replacing or reducing the number of expensive laboratory experiments by an <italic>in silico</italic> prediction will reduce costs. However, peptides having a low bioactivity do not qualify as drug precursors. Instead, we should focus on identifying the most bioactive ones. The computational problem is thus to identify and sort peptides according to a specific biological function. Let <inline-formula id="pcbi.1004074.e017"><alternatives><graphic xlink:href="pcbi.1004074.e017.jpg" id="pcbi.1004074.e017g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M17"><mml:mo>&#x1d4d0;</mml:mo></mml:math></alternatives></inline-formula> be the set of all amino acids, and <inline-formula id="pcbi.1004074.e018"><alternatives><graphic xlink:href="pcbi.1004074.e018.jpg" id="pcbi.1004074.e018g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M18"><mml:mrow><mml:msup><mml:mo>&#x1d4d0;</mml:mo><mml:mi>l</mml:mi></mml:msup></mml:mrow></mml:math></alternatives></inline-formula> be the set of all possible peptides of length <italic>l</italic>. Then, finding the peptide <inline-formula id="pcbi.1004074.e019"><alternatives><graphic xlink:href="pcbi.1004074.e019.jpg" id="pcbi.1004074.e019g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M19"><mml:mrow><mml:msup><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>x</mml:mi></mml:mstyle><mml:mo>&#x022c6;</mml:mo></mml:msup><mml:mo>&#x02208;</mml:mo><mml:msup><mml:mo>&#x1d4d0;</mml:mo><mml:mi>l</mml:mi></mml:msup></mml:mrow></mml:math></alternatives></inline-formula> that, according to <italic>h</italic>
<sub><bold>y</bold></sub>, has the maximal bioactivity with <bold>y</bold>, amounts at solving
<disp-formula id="pcbi.1004074.e020"><alternatives><graphic xlink:href="pcbi.1004074.e020.jpg" id="pcbi.1004074.e020g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M20"><mml:mrow><mml:msubsup><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>x</mml:mi></mml:mstyle><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>y</mml:mi></mml:mstyle><mml:mo>&#x022c6;</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mi>arg</mml:mi><mml:mspace width="1pt"/><mml:munder><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>x</mml:mi></mml:mstyle><mml:mo>&#x02208;</mml:mo><mml:msup><mml:mo>&#x1d4d0;</mml:mo><mml:mi>l</mml:mi></mml:msup></mml:mrow></mml:munder><mml:mspace width="1pt"/><mml:msub><mml:mi>h</mml:mi><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>y</mml:mi></mml:mstyle></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>x</mml:mi></mml:mstyle><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></alternatives><label>(7)</label></disp-formula>
This combinatorial problem is complex because, according to the predictor <italic>h</italic>
<sub><bold>y</bold></sub>, the contribution of an amino acid at a certain position also depend on the <italic>k</italic> &#x02212; 1 adjacent amino acids. This is the case since string kernel use <italic>k</italic>-mers to compare sequences. For that reason, each amino acid of the peptide cannot be optimized independently, but globally. Moreover, since the number of possible peptides grows exponentially with <italic>l</italic> (the length of the peptide), a brute force algorithm has an intractable complexity of <inline-formula id="pcbi.1004074.e021"><alternatives><graphic xlink:href="pcbi.1004074.e021.jpg" id="pcbi.1004074.e021g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M21"><mml:mrow><mml:mo>&#x1d4de;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mo>&#x1d4d0;</mml:mo><mml:msup><mml:mo>|</mml:mo><mml:mi>l</mml:mi></mml:msup><mml:mo>&#x02219;</mml:mo><mml:mspace width="1pt"/><mml:mo>&#x1d4de;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>h</mml:mi><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>y</mml:mi></mml:mstyle></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> where <inline-formula id="pcbi.1004074.e022"><alternatives><graphic xlink:href="pcbi.1004074.e022.jpg" id="pcbi.1004074.e022g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M22"><mml:mrow><mml:mo>&#x1d4de;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>h</mml:mi><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>y</mml:mi></mml:mstyle></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> denotes the worst case time complexity for computing <italic>h</italic>
<sub><bold>y</bold></sub>(<bold>x</bold>), the output of the predictor on peptide a <bold>x</bold>. Such an algorithm becomes impractical for any peptide exceeding 6 amino acids.</p><p>When facing such task, heuristics and stochastic optimization methods were generally the methods of choice [<xref rid="pcbi.1004074.ref024" ref-type="bibr">24</xref>, <xref rid="pcbi.1004074.ref025" ref-type="bibr">25</xref>]. However, these methods often require prohibitive CPU time and are not guaranteed to find the optimal solution. In addition, these approaches are not capable of sorting the best solutions since they are designed to find a single maximum.</p><p>In the next section, we present an efficient algorithm guaranteed to solve <xref ref-type="disp-formula" rid="pcbi.1004074.e020">Equation (7)</xref>. We also present a second algorithm capable of sorting in decreasing order the peptides maximizing <xref ref-type="disp-formula" rid="pcbi.1004074.e020">Equation (7)</xref>. Both algorithms have low asymptotic computational complexity, yielding tractable applications for the design and screening of peptides.</p></sec><sec id="sec002d"><title>Finding the peptide of maximal bioactivity</title><p>Here, we assume that we have, for a fixed target <bold>y</bold>, a prediction function <italic>h</italic>
<sub><bold>y</bold></sub>(<bold>x</bold>) given by <xref ref-type="disp-formula" rid="pcbi.1004074.e013">Equation (6)</xref>. In this case, we show how the problem of finding, the peptide <inline-formula id="pcbi.1004074.e023"><alternatives><graphic xlink:href="pcbi.1004074.e023.jpg" id="pcbi.1004074.e023g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M23"><mml:mrow><mml:msubsup><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>x</mml:mi></mml:mstyle><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>y</mml:mi></mml:mstyle><mml:mo>&#x022c6;</mml:mo></mml:msubsup><mml:mo>&#x02208;</mml:mo><mml:msup><mml:mo>&#x1d4d0;</mml:mo><mml:mi>l</mml:mi></mml:msup></mml:mrow></mml:math></alternatives></inline-formula> of maximal bioactivity reduces to the problem of finding the longest path in a directed acyclic graph (DAG). Note that, throughout this manuscript, we will assume that the length of a path is given by the sum of the weights on its edges. To solve this problem, we construct a DAG with a source and a sink vertex such that for all possible peptides <inline-formula id="pcbi.1004074.e024"><alternatives><graphic xlink:href="pcbi.1004074.e024.jpg" id="pcbi.1004074.e024g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M24"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>x</mml:mi></mml:mstyle><mml:mo>&#x02208;</mml:mo><mml:msup><mml:mo>&#x1d4d0;</mml:mo><mml:mi>l</mml:mi></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>, there exists only one path associated to <bold>x</bold> that goes from the source to the sink. Moreover, the length of the path associated to <bold>x</bold> is exactly <italic>h</italic>
<sub><bold>y</bold></sub>(<bold>x</bold>). Thus, if the size of the constructed graph is polynomial in <italic>l</italic>, any algorithm that efficiently solves the longest path problem in a DAG will also efficiently find the peptide of maximal bioactivity. A simplification of the graph is shown in <xref ref-type="fig" rid="pcbi.1004074.g001">Fig. 1</xref> to assist in the comprehension of the formal definition that follows.</p><fig id="pcbi.1004074.g001" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1004074.g001</object-id><label>Figure 1</label><caption><title>Illustration of the 3-partite graph <italic>G</italic>
<sup><italic>h</italic><sub><bold>y</bold></sub></sup> with <italic>k</italic> = 3 and a two letters alphabet <inline-formula id="pcbi.1004074.e025"><inline-graphic xlink:href="pcbi.1004074.e025.jpg"/></inline-formula>.</title><p>In this graph, every source-sink path represent a peptide of size 5 (<italic>l</italic> = <italic>n</italic> + <italic>k</italic> &#x02212; 1) based on the alphabet {<italic>A, B</italic>}.</p></caption><graphic xlink:href="pcbi.1004074.g001"/></fig><p>A directed bipartite graph is a graph whose vertices can be divided into two disjoint sets such that every directed edge connects a vertex of the first set to the second set. The construction of the graph will proceed as follows.</p><p>Let <italic>k</italic> be the maximal length of <italic>k</italic>-mers considered by the GS kernel. Let <inline-formula id="pcbi.1004074.e026"><alternatives><graphic xlink:href="pcbi.1004074.e026.jpg" id="pcbi.1004074.e026g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M26"><mml:mrow><mml:msub><mml:mi>U</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mover><mml:mo>=</mml:mo><mml:mrow><mml:mtext>def</mml:mtext></mml:mrow></mml:mover><mml:msup><mml:mo>&#x1d4d0;</mml:mo><mml:mi>k</mml:mi></mml:msup><mml:mo>&#x000d7;</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mi>i</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>, in other words, the set <italic>U</italic>
<sub><italic>i</italic></sub> contains all tuples (<italic>s, i</italic>) where <italic>s</italic> is a <italic>k</italic>-mer and <italic>i</italic> an integer. Let <italic>G</italic>
<sub><italic>i</italic></sub> = ((<italic>U</italic>
<sub><italic>i</italic></sub>, <italic>U</italic>
<sub><italic>i</italic>+1</sub>), <italic>E</italic>
<sub><italic>i</italic></sub>) be the <italic>i</italic>-th directed bipartite graph of some set where the set of directed edges <italic>E</italic>
<sub><italic>i</italic></sub> is defined as follows. Similarly as in the de Bruijn graph, there is a directed edge ((<italic>s, i</italic>), (<italic>s</italic>&#x02032;, <italic>i</italic>+1)) from (<italic>s, i</italic>) in <italic>U</italic>
<sub><italic>i</italic></sub> to (<italic>s</italic>&#x02032;, <italic>i</italic>+1) in <italic>U</italic>
<sub><italic>i</italic>+1</sub> if and only if the last <italic>k</italic> &#x02212; 1 amino acids of <italic>s</italic> are the same as the first <italic>k</italic> &#x02212; 1 amino acids of <italic>s</italic>&#x02032;. For example, in the graph of <xref ref-type="fig" rid="pcbi.1004074.g001">Fig. 1</xref>, there is an edge from (<italic>ABA</italic>, 1) to (<italic>BAA</italic>, 2) with <italic>k</italic> = 3. Note that &#x02200;<italic>i</italic> &#x02208; &#x02115;, directed edges in <italic>G</italic>
<sub><italic>i</italic></sub> only go from vertices in <italic>U</italic>
<sub><italic>i</italic></sub> to vertices in <italic>U</italic>
<sub><italic>i</italic>+1</sub>. There are exactly <inline-formula id="pcbi.1004074.e027"><alternatives><graphic xlink:href="pcbi.1004074.e027.jpg" id="pcbi.1004074.e027g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M27"><mml:mrow><mml:mo>|</mml:mo><mml:mo>&#x1d4d0;</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> edges that leave each vertex in <italic>U</italic>
<sub><italic>i</italic></sub> and there are exactly <inline-formula id="pcbi.1004074.e028"><alternatives><graphic xlink:href="pcbi.1004074.e028.jpg" id="pcbi.1004074.e028g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M28"><mml:mrow><mml:mo>|</mml:mo><mml:mo>&#x1d4d0;</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> edges that point to each vertex in <italic>U</italic>
<sub><italic>i</italic>+1</sub>. Moreover, for any chosen integer <italic>k</italic>, <inline-formula id="pcbi.1004074.e029"><alternatives><graphic xlink:href="pcbi.1004074.e029.jpg" id="pcbi.1004074.e029g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M29"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mi>U</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mspace width="1pt"/><mml:mo>=</mml:mo><mml:mspace width="1pt"/><mml:mo>|</mml:mo><mml:msub><mml:mi>U</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>|</mml:mo><mml:mspace width="1pt"/><mml:mo>=</mml:mo><mml:mspace width="1pt"/><mml:mo>|</mml:mo><mml:msup><mml:mo>&#x1d4d0;</mml:mo><mml:mi>k</mml:mi></mml:msup><mml:mo>|</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1004074.e030"><alternatives><graphic xlink:href="pcbi.1004074.e030.jpg" id="pcbi.1004074.e030g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M30"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mi>E</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mspace width="1pt"/><mml:mo>=</mml:mo><mml:mspace width="1pt"/><mml:mo>|</mml:mo><mml:msup><mml:mo>&#x1d4d0;</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>|</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. Note that there is a one-to-one correspondence between a sequence in <inline-formula id="pcbi.1004074.e031"><alternatives><graphic xlink:href="pcbi.1004074.e031.jpg" id="pcbi.1004074.e031g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M31"><mml:mrow><mml:msup><mml:mo>&#x1d4d0;</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></alternatives></inline-formula> and a single edge path from a vertex in <italic>U</italic>
<sub><italic>i</italic></sub> to a vertex in <italic>U</italic>
<sub><italic>i</italic>+1</sub>.</p><p>We define a <italic>n</italic>-partite graph as the union of <italic>n</italic> &#x02212; 1 bipartite graphs:
<disp-formula id="pcbi.1004074.e032"><alternatives><graphic xlink:href="pcbi.1004074.e032.jpg" id="pcbi.1004074.e032g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M32"><mml:mrow><mml:msub><mml:mi>G</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>&#x0222a;</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>&#x0222a;</mml:mo><mml:msub><mml:mi>G</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mover><mml:mo>=</mml:mo><mml:mtext>def</mml:mtext></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>U</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>U</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>U</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>U</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>E</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>&#x0222a;</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>&#x0222a;</mml:mo><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></alternatives></disp-formula>
</p><p>Finally, let <italic>G</italic>
<sup><italic>h</italic><sub><bold>y</bold></sub></sup> be a <italic>n</italic>-partite graph with the addition of a source node <italic>&#x003bb;</italic> and a sink node <italic>t</italic>. We choose the letter <italic>&#x003bb;</italic> for the source node since it can be interpreted as the empty string (a 0-mer) node. There is a directed edge from <italic>&#x003bb;</italic> to all nodes of <italic>U</italic>
<sub>1</sub> and from all nodes of <italic>U</italic>
<sub><italic>n</italic></sub> to <italic>t</italic>. For example, the graph illustrated in <xref ref-type="fig" rid="pcbi.1004074.g001">Fig. 1</xref> is a 3-partite graph with a source and a sink node when the <italic>k</italic>-mer are of size 3 and the alphabet has two letters: A and B.</p><p>Throughout this manuscript, we will only focus on paths starting at <italic>&#x003bb;</italic>, the source node, and ending at <italic>t</italic>, the sink node. For this reason, by choosing <italic>n</italic> = <italic>l</italic> &#x02212;<italic>k</italic> + 1 we obtain the one-to-one correspondence between each peptide of <inline-formula id="pcbi.1004074.e033"><alternatives><graphic xlink:href="pcbi.1004074.e033.jpg" id="pcbi.1004074.e033g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M33"><mml:mrow><mml:msup><mml:mo>&#x1d4d0;</mml:mo><mml:mi>l</mml:mi></mml:msup></mml:mrow></mml:math></alternatives></inline-formula> and each path <italic>&#x003bb;</italic>, <italic>u</italic>
<sub>1</sub>, &#x02026;, <italic>u</italic>
<sub><italic>n</italic></sub>, <italic>t</italic> where <italic>u</italic>
<sub><italic>i</italic></sub> &#x02208; <italic>U</italic>
<sub><italic>i</italic></sub>. For example, in <xref ref-type="fig" rid="pcbi.1004074.g001">Fig. 1</xref> the peptide ABAAA of size <italic>l</italic> = 5 is represented by the path <italic>&#x003bb;</italic>, (<italic>ABA</italic>, 1), (<italic>BAA</italic>, 2), (<italic>AAA</italic>, 3), <italic>t</italic>.</p><p>Let us now describe how edges in <italic>G</italic>
<sup><italic>h</italic><sub><bold>y</bold></sub></sup> are weighted in order for the length of a path associated to <bold>x</bold> to be exactly <italic>h</italic>
<sub><bold>y</bold></sub>(<bold>x</bold>), the predicted bioactivity of <bold>x</bold>. Using the definition of the GS kernel, given at <xref ref-type="disp-formula" rid="pcbi.1004074.e008">Equation (4)</xref>, and the general class of predictors, given by <xref ref-type="disp-formula" rid="pcbi.1004074.e013">Equation (6)</xref>, we can rewrite <italic>h</italic>
<sub><bold>y</bold></sub>(<bold>x</bold>) as
<disp-formula id="pcbi.1004074.e034"><alternatives><graphic xlink:href="pcbi.1004074.e034.jpg" id="pcbi.1004074.e034g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M34"><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>y</mml:mi></mml:mstyle></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>x</mml:mi></mml:mstyle><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mstyle mathsize="140%" displaystyle="true"><mml:mo>&#x02211;</mml:mo></mml:mstyle><mml:mrow><mml:mi>q</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:munderover><mml:mspace width="1pt"/><mml:msub><mml:mi>&#x003b2;</mml:mi><mml:mi>q</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>y</mml:mi></mml:mstyle><mml:mo stretchy="false">)</mml:mo><mml:munderover><mml:mstyle mathsize="140%" displaystyle="true"><mml:mo>&#x02211;</mml:mo></mml:mstyle><mml:mrow><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:munderover><mml:mstyle mathsize="140%" displaystyle="true"><mml:mo>&#x02211;</mml:mo></mml:mstyle><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:mo>&#x02223;</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>x</mml:mi></mml:mstyle><mml:mo>&#x02223;</mml:mo></mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:munderover><mml:munderover><mml:mstyle mathsize="140%" displaystyle="true"><mml:mo>&#x02211;</mml:mo></mml:mstyle><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:mo>&#x02223;</mml:mo><mml:mrow><mml:msub><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>x</mml:mi></mml:mstyle><mml:mi>q</mml:mi></mml:msub></mml:mrow><mml:mo>&#x02223;</mml:mo></mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:munderover><mml:mi>exp</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:msubsup><mml:mi>&#x003c3;</mml:mi><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mi>exp</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mo>&#x02016;</mml:mo><mml:msup><mml:mi mathvariant="bold">&#x003c8;</mml:mi><mml:mi>p</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>x</mml:mi></mml:mstyle><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mn>..</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>x</mml:mi></mml:mstyle><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02212;</mml:mo><mml:msup><mml:mi mathvariant="bold">&#x003c8;</mml:mi><mml:mi>p</mml:mi></mml:msup><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>x</mml:mi></mml:mstyle><mml:mi>q</mml:mi></mml:msub><mml:msub><mml:mrow/><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mn>..</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>x</mml:mi></mml:mstyle><mml:mi>q</mml:mi></mml:msub><mml:msub><mml:mrow/><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02016;</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:msubsup><mml:mi>&#x003c3;</mml:mi><mml:mi>c</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></alternatives></disp-formula>
For any <italic>k</italic>-mers <italic>s</italic> and any <italic>i</italic> &#x02208; {1, &#x02026;, <italic>n</italic>}, we define
<disp-formula id="pcbi.1004074.e035"><alternatives><graphic xlink:href="pcbi.1004074.e035.jpg" id="pcbi.1004074.e035g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M35"><mml:mrow><mml:mi>W</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mover><mml:mo>=</mml:mo><mml:mrow><mml:mtext>def</mml:mtext></mml:mrow></mml:mover><mml:munderover><mml:mstyle mathsize="140%" displaystyle="true"><mml:mo>&#x02211;</mml:mo></mml:mstyle><mml:mrow><mml:mi>q</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:munderover><mml:mspace width="1pt"/><mml:msub><mml:mi>&#x003b2;</mml:mi><mml:mi>q</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>y</mml:mi></mml:mstyle><mml:mo stretchy="false">)</mml:mo><mml:munderover><mml:mstyle mathsize="140%" displaystyle="true"><mml:mo>&#x02211;</mml:mo></mml:mstyle><mml:mrow><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:munderover><mml:mstyle mathsize="140%" displaystyle="true"><mml:mo>&#x02211;</mml:mo></mml:mstyle><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:mo>&#x02223;</mml:mo><mml:mrow><mml:msub><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>x</mml:mi></mml:mstyle><mml:mi>q</mml:mi></mml:msub></mml:mrow><mml:mo>&#x02223;</mml:mo></mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:munderover><mml:mi>exp</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:msubsup><mml:mi>&#x003c3;</mml:mi><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mi>exp</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mo>&#x02016;</mml:mo><mml:msup><mml:mi mathvariant="bold">&#x003c8;</mml:mi><mml:mi>p</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02212;</mml:mo><mml:msup><mml:mi mathvariant="bold">&#x003c8;</mml:mi><mml:mi>p</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>x</mml:mi></mml:mstyle><mml:mi>q</mml:mi></mml:msub><mml:msub><mml:mrow/><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mn>..</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>x</mml:mi></mml:mstyle><mml:mi>q</mml:mi></mml:msub><mml:msub><mml:mrow/><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msup><mml:mo>&#x02016;</mml:mo><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:msubsup><mml:mi>&#x003c3;</mml:mi><mml:mi>c</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives><label>(8)</label></disp-formula>
as the weight on edges heading to the node <inline-formula id="pcbi.1004074.e036"><alternatives><graphic xlink:href="pcbi.1004074.e036.jpg" id="pcbi.1004074.e036g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M36"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02208;</mml:mo><mml:msup><mml:mo>&#x1d4d0;</mml:mo><mml:mi>k</mml:mi></mml:msup><mml:mo>&#x000d7;</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. The function <italic>W</italic> weight all edges of <italic>G</italic>
<sup><italic>h</italic><sub><bold>y</bold></sub></sup> except those heading to the sink vertex <italic>t</italic>. When <italic>k</italic> &#x0003e; 1, edges ((<italic>s, n</italic>), <italic>t</italic>), heading to the sink vertex <italic>t</italic>, are weighted by the function
<disp-formula id="pcbi.1004074.e037"><alternatives><graphic xlink:href="pcbi.1004074.e037.jpg" id="pcbi.1004074.e037g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M37"><mml:mrow><mml:msub><mml:mi>W</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mi>W</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>&#x02026;</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives><label>(9)</label></disp-formula>
otherwise, <italic>W</italic>
<sub><italic>t</italic></sub>(<italic>s</italic>) = 0 when <italic>k</italic> = 1.</p><p>For <italic>n</italic> = <italic>l</italic> &#x02212; <italic>k</italic> + 1, we now have that
<disp-formula id="pcbi.1004074.e038"><alternatives><graphic xlink:href="pcbi.1004074.e038.jpg" id="pcbi.1004074.e038g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M38"><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>y</mml:mi></mml:mstyle></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>x</mml:mi></mml:mstyle><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>W</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mn>..</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mi>W</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mn>..</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></alternatives></disp-formula>
Therefore, every path from the source to the sink in <italic>G</italic>
<sup><italic>h</italic><sub><bold>y</bold></sub></sup> represents a unique peptide <inline-formula id="pcbi.1004074.e039"><alternatives><graphic xlink:href="pcbi.1004074.e039.jpg" id="pcbi.1004074.e039g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M39"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>x</mml:mi></mml:mstyle><mml:mo>&#x02208;</mml:mo><mml:msup><mml:mo>&#x1d4d0;</mml:mo><mml:mi>l</mml:mi></mml:msup></mml:mrow></mml:math></alternatives></inline-formula> and its estimated bioactivity <italic>h</italic>
<sub><bold>y</bold></sub>(<bold>x</bold>) is given by the length of the path.</p><p>The problem of finding the peptide of highest predicted activity thus reduces to the problem of finding the longest path in <italic>G</italic>
<sup><italic>h</italic><sub><bold>y</bold></sub></sup>. Despite being NP-hard in the general case, the longest path problem can be solved by dynamic programming in <inline-formula id="pcbi.1004074.e040"><alternatives><graphic xlink:href="pcbi.1004074.e040.jpg" id="pcbi.1004074.e040g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M40"><mml:mrow><mml:mo>&#x1d4de;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>G</mml:mi><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>y</mml:mi></mml:mstyle></mml:msub></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>G</mml:mi><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>y</mml:mi></mml:mstyle></mml:msub></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> for a directed acyclic graph, given a topological ordering of its vertices. By construction, <italic>G</italic>
<sup><italic>h</italic><sub><bold>y</bold></sub></sup> is clearly acyclic and its vertices can always be topologically ordered by visiting them in the following order: <italic>&#x003bb;</italic>, <italic>U</italic>
<sub>1</sub>, &#x02026;, <italic>U</italic>
<sub><italic>n</italic></sub>, <italic>t</italic>. Since <italic>G</italic>
<sup><italic>h</italic><sub><bold>y</bold></sub></sup> has <inline-formula id="pcbi.1004074.e041"><alternatives><graphic xlink:href="pcbi.1004074.e041.jpg" id="pcbi.1004074.e041g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M41"><mml:mrow><mml:mi>n</mml:mi><mml:mo>|</mml:mo><mml:mo>&#x1d4d0;</mml:mo><mml:msup><mml:mo>|</mml:mo><mml:mi>k</mml:mi></mml:msup><mml:mo>+</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></alternatives></inline-formula> vertices and <inline-formula id="pcbi.1004074.e042"><alternatives><graphic xlink:href="pcbi.1004074.e042.jpg" id="pcbi.1004074.e042g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M42"><mml:mrow><mml:mn>2</mml:mn><mml:mo>|</mml:mo><mml:mo>&#x1d4d0;</mml:mo><mml:msup><mml:mo>|</mml:mo><mml:mi>k</mml:mi></mml:msup><mml:mo>+</mml:mo><mml:mspace width="1pt"/><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>&#x1d4d0;</mml:mo><mml:msup><mml:mo>|</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></alternatives></inline-formula> edges, the complexity of the algorithm will be dominated by the number of edges. Therefore, the proposed algorithm has a complexity of <inline-formula id="pcbi.1004074.e043"><alternatives><graphic xlink:href="pcbi.1004074.e043.jpg" id="pcbi.1004074.e043g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M43"><mml:mrow><mml:mo>&#x1d4de;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>|</mml:mo><mml:mo>&#x1d4d0;</mml:mo><mml:msup><mml:mo>|</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. Recall that <italic>k</italic> is a constant and <italic>l</italic> is the length of the best peptide we are trying to identify. Thus, <italic>n</italic> must be equal to <italic>l</italic> &#x02212;<italic>k</italic> + 1.</p><p>Note that <xref ref-type="disp-formula" rid="pcbi.1004074.e035">Equation (8)</xref> has to be evaluated for each edge of the graph. The dynamic programming algorithm proposed for the computation of the GS kernel [<xref rid="pcbi.1004074.ref014" ref-type="bibr">14</xref>] can easily be adapted to efficiently evaluate this equation. In that case, the complexity of the weight function is reduced to <inline-formula id="pcbi.1004074.e044"><alternatives><graphic xlink:href="pcbi.1004074.e044.jpg" id="pcbi.1004074.e044g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M44"><mml:mrow><mml:mo>&#x1d4de;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>&#x02219;</mml:mo><mml:mi>l</mml:mi><mml:mo>&#x02219;</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>.</p><p>Small values of <italic>k</italic> are motivated by the fact that <inline-formula id="pcbi.1004074.e045"><alternatives><graphic xlink:href="pcbi.1004074.e045.jpg" id="pcbi.1004074.e045g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M45"><mml:mrow><mml:mo>&#x02016;</mml:mo><mml:mspace width="1pt"/><mml:msup><mml:mi mathvariant="bold">&#x003c8;</mml:mi><mml:mi>k</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mn>..</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mspace width="1pt"/><mml:mo>&#x02212;</mml:mo><mml:mspace width="1pt"/><mml:msup><mml:mi mathvariant="bold">&#x003c8;</mml:mi><mml:mi>k</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:msup><mml:mi>a</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mn>..</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:msup><mml:mi>a</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mspace width="1pt"/><mml:mspace width="1pt"/><mml:msup><mml:mo>&#x02016;</mml:mo><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:math></alternatives></inline-formula> is a monotonically increasing function of <italic>k</italic>. <xref ref-type="disp-formula" rid="pcbi.1004074.e007">Equation (3)</xref> will thus vanish exponentially fast as <italic>k</italic> increases. Long <italic>k</italic>-mers will thus have negligible influence on the estimated bioactivity, explaining why small values of <italic>k</italic> &#x02264; 6 &#x0226a; <italic>l</italic> are empirically chosen by cross-validation. Therefore, the time complexity of the proposed algorithm is orders of magnitude lower than the brute force algorithm which is in <inline-formula id="pcbi.1004074.e046"><alternatives><graphic xlink:href="pcbi.1004074.e046.jpg" id="pcbi.1004074.e046g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M46"><mml:mrow><mml:mo>&#x1d4de;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mo>&#x1d4d0;</mml:mo><mml:msup><mml:mo>|</mml:mo><mml:mi>l</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> since <italic>k</italic> &#x02264; 6 &#x0226a; <italic>l</italic> in practice. The pseudo-code to find the longest path in <italic>G</italic>
<sup><italic>h</italic><sub><bold>y</bold></sub></sup> is given in <xref ref-type="boxed-text" rid="pcbi.1004074.box001">Box 1</xref>.</p><boxed-text id="pcbi.1004074.box001" position="float" orientation="portrait"><sec id="sec002da"><title>Box 1. Algorithm for finding the longest path between the source node <italic>&#x003bb;</italic> and the sink node <italic>t</italic> in <italic>G</italic>
<sup><italic>h</italic><sub><bold>y</bold></sub></sup>
</title><p specific-use="line">
<italic>length</italic>_<italic>to</italic> = array with <inline-formula id="pcbi.1004074.e047"><alternatives><graphic xlink:href="pcbi.1004074.e047.jpg" id="pcbi.1004074.e047g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M47"><mml:mrow><mml:mi>n</mml:mi><mml:mo>|</mml:mo><mml:mo>&#x1d4d0;</mml:mo><mml:msup><mml:mo>|</mml:mo><mml:mi>k</mml:mi></mml:msup><mml:mo>+</mml:mo><mml:mspace width="1pt"/><mml:mn>2</mml:mn></mml:mrow></mml:math></alternatives></inline-formula> entries initialized to &#x02212;&#x0221e;</p><p specific-use="line">
<italic>predecessor</italic> = array with <inline-formula id="pcbi.1004074.e048"><alternatives><graphic xlink:href="pcbi.1004074.e048.jpg" id="pcbi.1004074.e048g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M48"><mml:mrow><mml:mi>n</mml:mi><mml:mo>|</mml:mo><mml:mo>&#x1d4d0;</mml:mo><mml:msup><mml:mo>|</mml:mo><mml:mi>k</mml:mi></mml:msup><mml:mo>+</mml:mo><mml:mspace width="1pt"/><mml:mn>2</mml:mn></mml:mrow></mml:math></alternatives></inline-formula> entries</p><p specific-use="line">
<bold>for all</bold>
<inline-formula id="pcbi.1004074.e049"><alternatives><graphic xlink:href="pcbi.1004074.e049.jpg" id="pcbi.1004074.e049g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M49"><mml:mrow><mml:mi>s</mml:mi><mml:mo>&#x02208;</mml:mo><mml:msup><mml:mo>&#x1d4d0;</mml:mo><mml:mi>k</mml:mi></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>
<bold>do</bold>&#x02003;&#x02003;&#x02003;&#x02003;&#x02003;&#x02003;&#x02003;&#x02003;&#x025b7;<bold>Edges leaving the source node</bold>
</p><p specific-use="line">&#x02003;&#x02003;
<italic>length</italic>_<italic>to</italic>[<italic>s</italic>, 1] &#x02190; <italic>W</italic>(<italic>s</italic>,1)</p><p specific-use="line">
<bold>end for</bold>
</p><p specific-use="line">
<bold>for</bold>
<italic>i</italic> = 2 &#x02192; <italic>n</italic>
<bold>do</bold>&#x02003;&#x02003;&#x02003;&#x02003;&#x02003;&#x02003;&#x02003;&#x02003;&#x025b7;<bold>Edges from the core of</bold>
<italic>G</italic>
<sup><italic>h</italic><sub><bold>y</bold></sub></sup>
</p><p specific-use="line">&#x02003;
<bold>for all</bold>
<inline-formula id="pcbi.1004074.e050"><alternatives><graphic xlink:href="pcbi.1004074.e050.jpg" id="pcbi.1004074.e050g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M50"><mml:mrow><mml:mi>s</mml:mi><mml:mo>&#x02208;</mml:mo><mml:msup><mml:mo>&#x1d4d0;</mml:mo><mml:mi>k</mml:mi></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>
<bold>do</bold>
</p><p specific-use="line">&#x02003;&#x02003;
<bold>for all</bold>
<inline-formula id="pcbi.1004074.e051"><alternatives><graphic xlink:href="pcbi.1004074.e051.jpg" id="pcbi.1004074.e051g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M51"><mml:mrow><mml:mi>a</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mo>&#x1d4d0;</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
<bold>do</bold>
</p><p specific-use="line">&#x02003;&#x02003;&#x02003;
<italic>s</italic>&#x02032; &#x02190; <italic>s</italic>
<sub>2</sub>, &#x02026;, <italic>s</italic>
<sub><italic>k</italic></sub>, <italic>a</italic>&#x02003;&#x02003;&#x02003;&#x02003;&#x02003;&#x02003;&#x02003;&#x02003;&#x025b7;<bold>Note that <italic>s</italic>&#x02032; is a <italic>k</italic>-mers</bold>
</p><p specific-use="line">&#x02003;&#x02003;&#x02003;
<bold>If</bold>
<italic>length</italic>_<italic>to</italic>[<italic>s</italic>&#x02032;, <italic>i</italic>] &#x02264;<italic>length</italic>_<italic>to</italic>[<italic>s</italic>, <italic>i</italic> &#x02212;1] + <italic>W</italic>(<italic>s</italic>&#x02032;, <italic>i</italic>) <bold>then</bold>
</p><p specific-use="line">&#x02003;&#x02003;&#x02003;&#x02003;
<italic>length</italic>_<italic>to</italic>[<italic>s</italic>&#x02032;, <italic>i</italic>] &#x02190; <italic>length</italic>_<italic>to</italic>[<italic>s</italic>, <italic>i</italic> &#x02212; 1] + <italic>W</italic>(<italic>s</italic>&#x02032;, <italic>i</italic>)</p><p specific-use="line">&#x02003;&#x02003;&#x02003;&#x02003;
<italic>predecessor</italic>[<italic>s</italic>&#x02032;, <italic>i</italic>] &#x02190; <italic>s</italic>
</p><p specific-use="line">&#x02003;&#x02003;&#x02003;
<bold>end if</bold>
</p><p specific-use="line">&#x02003;&#x02003;
<bold>end for</bold>
</p><p specific-use="line">&#x02003;
<bold>end for</bold>
</p><p specific-use="line">
<bold>end for</bold>
</p><p specific-use="line">
<italic>max</italic>_<italic>length</italic> &#x02190; &#x02212; &#x0221e;</p><p specific-use="line">
<italic>longest</italic>_<italic>path</italic> &#x02190; <italic>&#x003bb;</italic>
</p><p specific-use="line">
<bold>for all</bold>
<inline-formula id="pcbi.1004074.e052"><alternatives><graphic xlink:href="pcbi.1004074.e052.jpg" id="pcbi.1004074.e052g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M52"><mml:mrow><mml:mi>s</mml:mi><mml:mo>&#x02208;</mml:mo><mml:msup><mml:mo>&#x1d4d0;</mml:mo><mml:mi>k</mml:mi></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>
<bold>do</bold>&#x02003;&#x02003;&#x02003;&#x02003;&#x02003;&#x02003;&#x02003;&#x02003;&#x025b7;<bold>Edges heading to the sink node</bold>
</p><p specific-use="line">&#x02003;
<bold>If</bold>
<italic>max</italic>_<italic>length</italic> &#x02264; <italic>length</italic>_<italic>to</italic>[<italic>s</italic>, <italic>n</italic>] + <italic>W</italic>
<sub><italic>t</italic></sub>(<italic>s</italic>) <bold>then</bold>
</p><p specific-use="line">&#x02003;&#x02003;
<italic>max</italic>_<italic>length</italic> &#x02190; <italic>length</italic>_<italic>to</italic>[<italic>s</italic>, <italic>n</italic>] + <italic>W</italic>
<sub><italic>t</italic></sub>(<italic>s</italic>)</p><p specific-use="line">&#x02003;&#x02003;
<italic>longest</italic>_<italic>path</italic> &#x02190; <italic>s</italic>
</p><p specific-use="line">&#x02003;
<bold>end if</bold>
</p><p specific-use="line">
<bold>end for</bold>
</p><p specific-use="line">
<bold>for</bold>
<italic>i</italic> = <italic>n</italic> &#x02192; 2 <bold>do</bold>&#x02003;&#x02003;&#x02003;&#x02003;&#x02003;&#x02003;&#x02003;&#x02003;&#x025b7;<bold>Backtrack using the predecessors</bold>
</p><p specific-use="line">&#x02003;
<italic>s</italic>
<sub>1</sub>, &#x02026;, <italic>s</italic>
<sub><italic>k</italic></sub> &#x02190; <italic>predecessor</italic>[<italic>longest</italic>_<italic>path</italic>
<sub>[1:<italic>k</italic>]</sub>, <italic>i</italic>]</p><p specific-use="line">&#x02003;
<italic>longest</italic>_<italic>path</italic> &#x02190; <italic>s</italic>
<sub>1</sub>, <italic>longest</italic>_<italic>path</italic>
</p><p specific-use="line">
<bold>end for</bold>
</p><p specific-use="line">
<bold>return</bold>
<italic>longest</italic>_<italic>path</italic>
</p></sec></boxed-text></sec><sec id="sec002e"><title>Finding the <italic>K</italic> peptides of maximal bioactivity</title><p>In the previous section, we demonstrated how the problem of finding the peptide of greatest predicted bioactivity was reduced to the problem of finding a path of maximal length in the graph <italic>G</italic>
<sup><italic>h</italic><sub><bold>y</bold></sub></sup>. By using the same arguments, finding the peptide with the second greatest predicted activity reduces to the problem of finding the second longest path in <italic>G</italic>
<sup><italic>h</italic><sub><bold>y</bold></sub></sup>. By induction, it follows that the problem of finding the <italic>K</italic> peptides of maximal predicted activity reduces to the problem of finding the <italic>K</italic>-longest paths in <italic>G</italic>
<sup><italic>h</italic><sub><bold>y</bold></sub></sup>. The closely-related <italic>K</italic>-shortest paths problem has been studied since 1957 and attracted considerable attention following the work of Yen [<xref rid="pcbi.1004074.ref026" ref-type="bibr">26</xref>]. Yen&#x02019;s algorithm was later improved by Lawler [<xref rid="pcbi.1004074.ref027" ref-type="bibr">27</xref>]. Both algorithms make use of a shortest path algorithms to solve the <italic>K</italic>-shortest paths problem. By exploiting some restrictive properties of <italic>G</italic>
<sup><italic>h</italic><sub><bold>y</bold></sub></sup>, Yen&#x02019;s algorithm for the <italic>K</italic>-shortest paths was adapted, shown in <xref ref-type="boxed-text" rid="pcbi.1004074.box002">Box 2</xref>, to find the <italic>K</italic>-longest paths in <italic>G</italic>
<sup><italic>h</italic><sub><bold>y</bold></sub></sup>. It uses a variant of the longest path algorithm presented in the previous section, that allows a path to start from any node of the graph. Lawler improvement to the algorithm is not part of the presented algorithm to avoid unnecessary confusion but is part of the implementation we provide. The time complexity of the resulting algorithm is competitive with the latest work on <italic>K</italic>-shortest paths algorithms [<xref rid="pcbi.1004074.ref028" ref-type="bibr">28</xref>, <xref rid="pcbi.1004074.ref029" ref-type="bibr">29</xref>].</p><boxed-text id="pcbi.1004074.box002" position="float" orientation="portrait"><sec id="sec002ea"><title>Box 2 Algorithm for finding the <italic>K</italic>-longest paths in <italic>G</italic>
<sup><italic>h</italic><sub><bold>y</bold></sub></sup>
</title><p specific-use="line">
<italic>A</italic> = <bold>array with</bold>
<italic>K</italic>
<bold>entries initialized with the empty string</bold>
</p><p specific-use="line">
<italic>B</italic> = <bold>max-heap to store potential paths and their lengths</bold>
</p><p specific-use="line">
<italic>A</italic>[0] &#x02190; <bold>LongestPath</bold> (<italic>G</italic>
<sup>h<sub><bold>y</bold></sub></sup>, &#x003bb;, <italic>t</italic>)</p><p specific-use="line">
<bold>for</bold>
<italic>i</italic> = 0 &#x02192; <italic>K</italic> &#x02212; 1 <bold>do</bold>
</p><p specific-use="line">&#x02003;
<bold>for all</bold> (<italic>a, j</italic>) <inline-formula id="pcbi.1004074.e066"><alternatives><graphic xlink:href="pcbi.1004074.e066.jpg" id="pcbi.1004074.e066g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M66"><mml:mo>&#x02208;</mml:mo></mml:math></alternatives></inline-formula> (&#x003bb;, (<italic>A</italic> [<italic>i</italic>]<sub>[0:<italic>k</italic>]</sub>, 1), &#x02026;, (<italic>A</italic> [<italic>i</italic>]<sub>[<italic>l</italic> &#x02212; <italic>k</italic>:<italic>l</italic>]</sub>, <italic>n</italic>)) <bold>do</bold>&#x02003;&#x02003;&#x02003;&#x02003;&#x02003;&#x02003;&#x02003;&#x02003;&#x025b7;<bold>Nodes of the previous path</bold>
</p><p specific-use="line">&#x02003;&#x02003;(<italic>V, E</italic>) &#x02190; <italic>G</italic>
<sup>h<sub><bold>y</bold></sub></sup>
</p><p specific-use="line">&#x02003;&#x02003;
<bold>root</bold> &#x02190; <italic>A</italic>[<italic>i</italic>]<sub>[0:<italic>j</italic>+<italic>k</italic>]</sub>
</p><p specific-use="line">&#x02003;&#x02003;
<bold>for</bold>
<italic>r</italic> = 0 &#x02192; <italic>i</italic>
<bold>do</bold>
</p><p specific-use="line">&#x02003;&#x02003;&#x02003;
<bold>If</bold>
<italic>A</italic>[<italic>r</italic>]<sub>[0:<italic>j</italic>+<italic>k</italic>]</sub> = <italic>root</italic>
<bold>then</bold>
</p><p specific-use="line">&#x02003;&#x02003;&#x02003;&#x02003;
<italic>E</italic> &#x02190; <italic>E</italic>\(<italic>A</italic>[<italic>r</italic>]<sub>[<italic>j</italic>:<italic>j</italic>+<italic>k</italic>]</sub>, <italic>j</italic>)</p><p specific-use="line">&#x02003;&#x02003;&#x02003;
<bold>end if</bold>
</p><p specific-use="line">&#x02003;&#x02003;
<bold>end for</bold>
</p><p specific-use="line">&#x02003;&#x02003;
<italic>x</italic> &#x02190; <bold>root</bold> + <bold>LongestPath</bold>((<italic>V</italic>, <italic>E</italic>), (<italic>a</italic>, <italic>j</italic>), <italic>t</italic>)</p><p specific-use="line">&#x02003;&#x02003;
<bold>if</bold>
<italic>x</italic> &#x02209; <italic>B</italic> &#x0222a; <italic>A</italic>
<bold>then</bold>
</p><p specific-use="line">&#x02003;&#x02003;&#x02003;
<italic>B.push</italic>(<italic>x</italic>, <italic>h</italic>
<sub><italic>y</italic></sub>(<italic>x</italic>))&#x02003;&#x02003;&#x02003;&#x02003;&#x02003;&#x02003;&#x02003;&#x02003;&#x025b7;<bold>Add the string and its length to the max-heap</bold>
</p><p specific-use="line">&#x02003;&#x02003;
<bold>end if</bold>
</p><p specific-use="line">&#x02003;
<bold>end for</bold>
</p><p specific-use="line">&#x02003;
<italic>A</italic>[<italic>i</italic> + 1] &#x02190; B.pop()&#x02003;&#x02003;&#x02003;&#x02003;&#x02003;&#x02003;&#x02003;&#x02003;&#x025b7;<bold><italic>B</italic>&#x02019;s longest path becomes the <italic>i</italic>-th longest path</bold>
</p><p specific-use="line">
<bold>end for</bold>
</p><p specific-use="line">
<bold>return A</bold>
</p></sec></boxed-text><p>The algorithm of <xref ref-type="boxed-text" rid="pcbi.1004074.box002">Box 2</xref> was implemented in a combination of both C and Python, the source code is freely available at <ext-link ext-link-type="uri" xlink:href="http://graal.ift.ulaval.ca/peptide-design/">http://graal.ift.ulaval.ca/peptide-design/</ext-link>. To validate the implementation and prevent potential flaws, it was successfully used to exhaustively sort all possible peptides of length 1 to 5 with various values of <italic>k, &#x003c3;</italic>
<sub><italic>p</italic></sub>, and <italic>&#x003c3;</italic>
<sub><italic>c</italic></sub>.</p><p>Having the <italic>K</italic> best peptides sorted according to their predicted bioactivity will provide valuable information with the potential of accelerating functional peptide discovery. Indeed, the best peptide candidates can be synthesized by an automated peptide synthesizer and tested <italic>in vitro</italic>. Such a procedure will allow rapid <italic>in vitro</italic> feedback and minimize turnaround time. Also, in the next section, we will describe how the <italic>K</italic> best predicted peptides can be utilized to predict a binding motif for a new, unstudied protein. Such a motif should assist researchers in the early study of a target and for the design of peptidomimetic compounds by providing residue preferences.</p></sec><sec id="sec002f"><title>From <italic>K</italic>-longest paths to motif</title><p>It is easy to use the <italic>K</italic>-longest paths algorithm to predict a motif by simply loading the <italic>K</italic> peptides to an existing motif tool. In this case, the motif is a property of the learned model <italic>h</italic>
<sub><bold>y</bold></sub>(<bold>x</bold>) as opposed to a consensus among known binding sequences. When <italic>h</italic>
<sub><bold>y</bold></sub>(<bold>x</bold>) is obtained from a multi-target model <italic>h</italic>(<bold>x</bold>, <bold>y</bold>), it is then possible to predict affinities for proteins with no known ligand by exploiting similarities with related proteins. It is therefore feasible to predict a binding motif for a target with no known binders. To our knowledge, this has never been realized successfully.</p></sec><sec id="sec002g"><title>Protocol for split and pool peptide synthesis</title><p>Split and pool combinatorial peptide synthesis is a simple but efficient way to synthesize a very wide spectrum of peptide ligands. It has been used for the discovery of ligands for receptors [<xref rid="pcbi.1004074.ref030" ref-type="bibr">30</xref>, <xref rid="pcbi.1004074.ref031" ref-type="bibr">31</xref>], for proteins [<xref rid="pcbi.1004074.ref032" ref-type="bibr">32</xref>&#x02013;<xref rid="pcbi.1004074.ref035" ref-type="bibr">35</xref>] and for transcription factors [<xref rid="pcbi.1004074.ref036" ref-type="bibr">36</xref>, <xref rid="pcbi.1004074.ref037" ref-type="bibr">37</xref>]. To synthesize several peptides of length <italic>l</italic> using the 20 natural amino acids, the standard approach is to use one reactor per natural amino acid and a pooling reactor. At every step of the experiment, all reactors are pooled into the pooling reactor which is then split, in equal proportions, back into the 20 amino acid reactors. Within this standard approach, each peptide in <inline-formula id="pcbi.1004074.e053"><alternatives><graphic xlink:href="pcbi.1004074.e053.jpg" id="pcbi.1004074.e053g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M53"><mml:mrow><mml:msup><mml:mo>&#x1d4d0;</mml:mo><mml:mi>l</mml:mi></mml:msup></mml:mrow></mml:math></alternatives></inline-formula> has an equal probability of being synthesized. Since the number of polystyrene beads (used to anchor every peptide) is generally orders of magnitude smaller than <inline-formula id="pcbi.1004074.e054"><alternatives><graphic xlink:href="pcbi.1004074.e054.jpg" id="pcbi.1004074.e054g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M54"><mml:mrow><mml:mo>|</mml:mo><mml:mo>&#x1d4d0;</mml:mo><mml:msup><mml:mo>|</mml:mo><mml:mi>l</mml:mi></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>, only a vanishingly small fraction of the peptides in <inline-formula id="pcbi.1004074.e055"><alternatives><graphic xlink:href="pcbi.1004074.e055.jpg" id="pcbi.1004074.e055g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M55"><mml:mrow><mml:msup><mml:mo>&#x1d4d0;</mml:mo><mml:mi>l</mml:mi></mml:msup></mml:mrow></mml:math></alternatives></inline-formula> can be synthesized in each combinatorial experiment.</p><p>Clearly, not every peptide has an equal probability of binding to a target. More restrictive protocols have been proposed to increase the hit ratio of this combinatorial experiment. For example, one could fix certain amino acids at specific positions or limit the set of possible amino acids at this position (for example, only use hydrophobic amino acids). Such practice will impact the outcome of the combinatorial experiment. One can probably increase the hit ratio by modifying (wisely) the proportion of amino acids that can be found at different positions in the peptides. To explore more thoroughly this possibility, let us define a (combinatorial chemistry) <italic>protocol</italic>
<italic>P</italic> by a <italic>l</italic>-tuple containing, for each position <italic>i</italic> in the peptide of length <italic>l</italic>, an independent distribution <inline-formula id="pcbi.1004074.e056"><alternatives><graphic xlink:href="pcbi.1004074.e056.jpg" id="pcbi.1004074.e056g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M56"><mml:mrow><mml:msub><mml:mo>&#x1d4df;</mml:mo><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> over the 20 amino acids <inline-formula id="pcbi.1004074.e057"><alternatives><graphic xlink:href="pcbi.1004074.e057.jpg" id="pcbi.1004074.e057g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M57"><mml:mrow><mml:mi>a</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mo>&#x1d4d0;</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. Hence, we define a protocol <italic>P</italic> by
<disp-formula id="pcbi.1004074.e058"><alternatives><graphic xlink:href="pcbi.1004074.e058.jpg" id="pcbi.1004074.e058g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M58"><mml:mrow><mml:mi>P</mml:mi><mml:mover><mml:mo>=</mml:mo><mml:mtext>def</mml:mtext></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mo>&#x1d4df;</mml:mo><mml:mi>1</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mo>&#x1d4df;</mml:mo><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></alternatives><label>(10)</label></disp-formula>
Consequently, the peptides produced by this protocol will be distributed following the joint distribution <inline-formula id="pcbi.1004074.e059"><alternatives><graphic xlink:href="pcbi.1004074.e059.jpg" id="pcbi.1004074.e059g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M59"><mml:mrow><mml:msub><mml:mo>&#x1d4df;</mml:mo><mml:mn>1</mml:mn></mml:msub><mml:mo>&#x000d7;</mml:mo><mml:mspace width="1pt"/><mml:mo>&#x02026;</mml:mo><mml:mspace width="1pt"/><mml:mo>&#x000d7;</mml:mo><mml:msub><mml:mo>&#x1d4df;</mml:mo><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>. Hence, the probability of synthesizing a peptide <bold>x</bold> of size <italic>l</italic> is given by
<disp-formula id="pcbi.1004074.e060"><alternatives><graphic xlink:href="pcbi.1004074.e060.jpg" id="pcbi.1004074.e060g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M60"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>x</mml:mi></mml:mstyle><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>&#x0220f;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>l</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mo>&#x1d4df;</mml:mo><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></alternatives><label>(11)</label></disp-formula>
Note that <italic>P</italic> formally defines a position-specific weight matrix (PSWM) that can be illustrated as a motif. Moreover, this family of protocols is easy to implement in the laboratory since, at each step <italic>i</italic>, it only requires splitting the content of the pooling reactor in proportions equal to the distribution <inline-formula id="pcbi.1004074.e061"><alternatives><graphic xlink:href="pcbi.1004074.e061.jpg" id="pcbi.1004074.e061g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M61"><mml:mrow><mml:msub><mml:mo>&#x1d4df;</mml:mo><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula> over amino acids. For example, if at position <italic>i</italic>, we wish to sample uniformly over each amino acid, then we will use <inline-formula id="pcbi.1004074.e062"><alternatives><graphic xlink:href="pcbi.1004074.e062.jpg" id="pcbi.1004074.e062g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M62"><mml:mrow><mml:msub><mml:mo>&#x1d4df;</mml:mo><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mn>20</mml:mn></mml:mrow></mml:math></alternatives></inline-formula> for all <inline-formula id="pcbi.1004074.e063"><alternatives><graphic xlink:href="pcbi.1004074.e063.jpg" id="pcbi.1004074.e063g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M63"><mml:mrow><mml:mi>a</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mo>&#x1d4d0;</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. If on the other hand, we wish, at position <italic>i</italic>, to sample amino acids C, D, or E with equal probability and the rest of the amino acids with probability 0, then we use <inline-formula id="pcbi.1004074.e064"><alternatives><graphic xlink:href="pcbi.1004074.e064.jpg" id="pcbi.1004074.e064g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M64"><mml:mrow><mml:msub><mml:mo>&#x1d4df;</mml:mo><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></alternatives></inline-formula> for <italic>a</italic> &#x02208; {<italic>C, D, E</italic>} and <inline-formula id="pcbi.1004074.e065"><alternatives><graphic xlink:href="pcbi.1004074.e065.jpg" id="pcbi.1004074.e065g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M65"><mml:mrow><mml:msub><mml:mo>&#x1d4df;</mml:mo><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mspace width="1pt"/><mml:mo>=</mml:mo><mml:mspace width="1pt"/><mml:mn>0</mml:mn></mml:mrow></mml:math></alternatives></inline-formula> for <italic>a</italic> different from either <italic>C</italic>, <italic>D</italic>, or <italic>E</italic>.</p></sec><sec id="sec002h"><title>Expected outcome of a library given a protocol</title><p>We present a method for efficiently computing exact statistics on the screening outcome of a peptide library synthesized according to a protocol <italic>P</italic>. Specifically, we present an algorithm to compute the average predicted bioactivity and its variance over all peptides that a protocol can synthesize. Note that it is intractable to compute these statistics by predicting the activity of each peptide.</p><p>Such statistics will, for example, assist chemists in designing a protocol with a greater hit ratio and avoid superfluous experiments. Furthermore, we will demonstrate in the next section that the computation of these statistics can be part of an iterative procedure to accelerate the discovery of bioactive peptides. Indeed, having the average predicted bioactivity data will help with the design of a protocol that synthesizes as many potential active candidates as possible. In addition, the predicted bioactivity variance will allow for better control of the exploration/exploitation trade off of the experiment. Finally, as described in the previous section, a widely used practice for optimizing peptides is to assign residues at certain positions or restrict them to those that have specific properties such as charge or hydrophobicity. It is now possible to quantify how such procedure will impact the bioactivity of combinatorially synthesized peptides.</p><p>The proposed approach makes use of the graph <italic>G</italic>
<sup><italic>h</italic><sub><bold>y</bold></sub></sup>, the protocol <italic>P</italic>, and a dynamic programming algorithm that exploits recurrences in the factorization of first and second order polynomials. This allows for the efficient computation of the first and second moment of <italic>h</italic>
<sub><bold>y</bold></sub> when peptides are drawn according to the distribution <italic>P</italic>. Then, the average and variance can easily be obtained from the first two moments. Details of the approach and the algorithm are given in supplementary material (see <xref ref-type="supplementary-material" rid="pcbi.1004074.s001">S1 Text</xref>).</p></sec><sec id="sec002i"><title>Application in combinatorial drug discovery</title><p>We propose an iterative process that makes use of the proposed algorithms to accelerate the discovery of bioactive peptides. The procedure is illustrated in <xref ref-type="fig" rid="pcbi.1004074.g002">Fig. 2</xref>. First, an initial set of random peptides is synthesized, typically using a split and pool approach. The peptides are assayed in laboratory to measure their bioactivities. At this point, most peptides are poor candidates. They are then used as a training set to produce a predictor <italic>h</italic>
<sub><bold>y</bold></sub>. Next, <italic>h</italic>
<sub><bold>y</bold></sub> is used for the generation of <italic>K</italic> bioactive peptides by finding the <italic>K</italic>-longest paths in <italic>G</italic>
<sup><italic>h</italic><sub><bold>y</bold></sub></sup> as described previously. A protocol <italic>P</italic> is constructed from these <italic>K</italic> bioactive peptides to assist the next round of combinatorial chemistry. Then, the algorithm described in the previous section is used to predict statistics on the protocol <italic>P</italic>. This ensures that the protocol meets expectations in terms of quality (average predicted bioactivity) and diversity (predicted bioactivity variance). To lower costs, one should proceed to synthesize and test the library only if expectations are met. This process can be repeated until the desired bioactivity is achieved.</p><fig id="pcbi.1004074.g002" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1004074.g002</object-id><label>Figure 2</label><caption><title>Iterative process for the design of peptide ligands.</title></caption><graphic xlink:href="pcbi.1004074.g002"/></fig></sec></sec><sec id="sec003"><title>Results/ Discussion</title><sec id="sec003a"><title>Data</title><p>Two public datasets were used to test and validate our approach. The first dataset consisted of 101 cationic antimicrobial pentadecapeptides (CAMPs) from the synthetic antibiotic peptides database [<xref rid="pcbi.1004074.ref038" ref-type="bibr">38</xref>]. Peptide antibacterial activities are expressed as the logarithm of bactericidal potency which is the average potency over 24 bacteria such as <italic>Escherichia coli, Bactero&#x000ef;des fragilis</italic>, and <italic>Staphylococcus aureus</italic>. The average antibacterial activity of the CAMPs dataset was 0.39 and the best peptide had an activity of 0.824.</p><p>The second dataset consisted of 31 bradykinin-potentiating pentapeptides (BPPs) reported in [<xref rid="pcbi.1004074.ref039" ref-type="bibr">39</xref>]. The bioactivities are expressed as the logarithm of the relative activity index compared to the peptide VESSK. The average bioactivity of the BPPs dataset was 0.71 and the best peptide had an activity of 2.73.</p></sec><sec id="sec003b"><title>Improving the bioactivity of peptides</title><p>To assess the capability of the proposed approach to improve upon known peptides, two experiments were carried out using the CAMPs and BPPs peptide datasets. For both experiments, a predictor of biological activity was learned by kernel ridge regression (KRR) for the each datasets: <italic>h</italic>
<sub><italic>CAMP</italic></sub> and <italic>h</italic>
<sub><italic>BPP</italic></sub>. Hyper-parameters for the GS kernel (<italic>k, &#x003c3;</italic>
<sub><italic>c</italic></sub>, <italic>&#x003c3;</italic>
<sub><italic>p</italic></sub>) and the kernel ridge regression (<italic>&#x003bb;</italic>) were chosen by standard cross-validation: <italic>k</italic> = 2, <italic>&#x003c3;</italic>
<sub><italic>c</italic></sub> = 6.4, <italic>&#x003c3;</italic>
<sub><italic>p</italic></sub> = 0.8, and <italic>&#x003bb;</italic> = 6.4 for <italic>h</italic>
<sub><italic>CAMP</italic></sub> and <italic>k</italic> = 3, <italic>&#x003c3;</italic>
<sub><italic>c</italic></sub> = 0.8, <italic>&#x003c3;</italic>
<sub><italic>p</italic></sub> = 0.2, and <italic>&#x003bb;</italic> = 0.4 for <italic>h</italic>
<sub><italic>BPP</italic></sub>.</p><sec id="sec003ba"><title>
<italic>In silico</italic> validation</title><p>Using the <italic>K</italic>-longest path algorithm and the learned predictors, we generated the <italic>K</italic> peptides (of the same length as those of the training data) having the greatest predicted biological activity.</p><p>For the CAMPs dataset, the proposed approach predicted that peptide WWKWWKRLRRLFLLV should have an antibacterial potency of 1.09, a logarithmic improvement of 0.266 over the best peptide in the training set (GWRLIKKILRVFKGL, 0.824), and a substantial improvement over the average potency of that dataset (average of 0.39). The antimicrobial activity of the top 100,000 peptides are showed in <xref ref-type="fig" rid="pcbi.1004074.g003">Fig. 3</xref>. We observe a smooth power law with only a few peptides having outstanding biological activity, as expected. As we will see in the next section, peptides at the top of the curve, hence having the best bioactivities, are very unlikely to be found by chance.</p><fig id="pcbi.1004074.g003" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1004074.g003</object-id><label>Figure 3</label><caption><title>The 100,000 peptides with highest antimicrobial activity found by the <italic>K</italic>-longest path algorithm.</title></caption><graphic xlink:href="pcbi.1004074.g003"/></fig><p>On the BPPs dataset, the proposed approach predicted that the pentapeptide IEWAK should have an activity of 2.195, slightly less than the best peptide of the training set (VEWAK, 2.73, predicted as 2.192). However, the predicted activity of IEWAK is much better than the average peptide activity of the dataset, which is 0.71. One may ask why IEWAK has a lower predicted biological activity than VEWAK, which was part of the training data. It is common for machine learning algorithms to sacrifice accuracy on the training data to prevent overfitting. Despite this small discrepancy, the model is very accurate on the training data (correlation coefficient of 0.97). Another possible explanation for this discrepancy is that the biological activity of VEWAK could be slightly erroneous as the learning algorithm could not find a simple model given such an outlier. It seems that the predicted activity of VEWAK is more coherent with the whole data than its measured activity.</p><p>Hence, our proposed learning algorithm predicts new peptides having biological activities equivalent to the best of the training set and, in some cases, substantially improved activities. The next section present an <italic>in vitro</italic> experiment that clearly demonstrate that in a real world test, our approach can generate bioactive peptides.</p></sec><sec id="sec003bb"><title>
<italic>In vitro</italic> validation</title><p>To further validate the approach, a number of antimicrobial peptides identified during the <italic>in silico</italic> validation were synthesized. Their antimicrobial activity against <italic>Escherichia coli</italic> and <italic>Staphylococcus aureus</italic> were measured in a growth inhibitory assay. Details on the synthesis and assay are given in the supplementary material (see <xref ref-type="supplementary-material" rid="pcbi.1004074.s001">S1 Text</xref>). The peptides were obtained using <italic>h</italic>
<sub><italic>CAMP</italic></sub>, the same predictor used during the previous validation.</p><p>The two most active peptides of the CAMPs dataset (Peptide #5 and #6) were synthesized for comparison. We also synthesized one peptide with poor activity (Peptides #7) as a control. We used the proposed approach with the predictor <italic>h</italic>
<sub><italic>CAMP</italic></sub> to generate a list of <italic>K</italic> = 1,000 peptide candidates with the highest predicted activity. From this list, we greedily selected three peptides such that they all differed by at least 4 amino acids from each others. This was done to maximize the chemical diversity among them. We then tested these peptides (Peptides #2, #3, #4) in a growth inhibitory assay. Results from the minimal inhibitory concentration assay are shown in <xref rid="pcbi.1004074.t002" ref-type="table">Table 2</xref>. Two of the three candidates had activities equal to the best peptide of the CAMPs dataset. We were intrigued by the failure of Peptide #4 and after investigation, the weak activity was due to poor water solubility. In a second series, we ensured that a filter for water solubility was employed. In this second series of tests, Peptide #1 showed (at least against <italic>E. coli</italic>) better activity than any of the original candidates from the CAMPs dataset, demonstrating that, in this limited biological experiment, we could improve the putative candidates using the proposed machine learning methodology. Finally, all predicted antimicrobial peptides are significantly different from those of the training set, sharing only 40% similarity with their most similar peptide in the CAMPs dataset.</p></sec></sec><sec id="sec003c"><title>Simulation of a drug discovery</title><p>Previously, we described a methodology (illustrated in <xref ref-type="fig" rid="pcbi.1004074.g002">Fig. 2</xref>) that uses machine learning to guide the combinatorial chemistry search for finding peptides with high bioactivity. However, before conducting such an expensive and time-consuming experiment, it is reasonable to first investigate, <italic>in silico</italic>, if the proposed methodology could find peptides having high bioactivity.</p><p>Hence, to validate the proposed methodology, we replaced the laboratory experiments that would quantify the bioactivity level of peptides by an oracle for each dataset. We choose to use <italic>h</italic>
<sub><italic>CAMP</italic></sub> and <italic>h</italic>
<sub><italic>BPP</italic></sub> as oracle as they represent, so far, the best understanding of the studied phenomena. These oracles will be used to quantify the bioactivity level of randomly generated peptides and those proposed by our methodology. Note that, examples used to learn the oracles are not available to our algorithm during the validation. Consequently, the validation method used was the following.</p><list list-type="order"><list-item><p>We randomly generated <italic>R</italic> peptides on a computer instead of using combinatorial chemistry.</p></list-item><list-item><p>To measure the bioactivities, we replaced the laboratory experiments by the oracle.</p></list-item><list-item><p>We used these random peptides of low bioactivities to learn a second predictor <italic>h</italic>
<sub><italic>random</italic></sub>.</p></list-item><list-item><p>The predictor <italic>h</italic>
<sub><italic>random</italic></sub> is used to initiate the graph-based approach. We then obtained the <italic>K</italic> potentially best peptides.</p></list-item><list-item><p>The new peptides bioactivities are validated by the oracle (instead of performing laboratory experiments).</p></list-item><list-item><p>Finally, we compared the bioactivities of the initial set of peptides (randomly generated) and those proposed by our approach.</p></list-item></list><p>
<bold>Finding peptides with high bioactivity</bold> The testing methodology was conducted twice on both the CAMPs and the BPPs datasets. Once by generating <italic>R</italic> = 100 peptides at Step 1 and considering the <italic>K</italic> = 100 best predicted peptides at Step 4 of the methodology, and then by starting over the validation with <italic>R</italic> = 1,000 and <italic>K</italic> = 1,000. Statistics on the random peptides and those proposed by our approach are shown in <xref rid="pcbi.1004074.t001" ref-type="table">Table 1</xref>.</p><table-wrap id="pcbi.1004074.t001" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1004074.t001</object-id><label>Table 1</label><caption><title>Results from the drug discovery simulation.</title></caption><alternatives><graphic id="pcbi.1004074.t001g" xlink:href="pcbi.1004074.t001"/><table frame="box" rules="all" border="0"><colgroup span="1"><col align="left" valign="top" span="1"/><col align="left" valign="top" span="1"/><col align="left" valign="top" span="1"/><col align="left" valign="top" span="1"/><col align="left" valign="top" span="1"/><col align="left" valign="top" span="1"/><col align="left" valign="top" span="1"/></colgroup><thead><tr><th align="left" rowspan="1" colspan="1"/><th align="left" rowspan="1" colspan="1"/><th colspan="2" align="center" rowspan="1">
<italic>R</italic> Randomly Picked</th><th colspan="2" align="center" rowspan="1">
<italic>K</italic> Best Predicted</th><th colspan="2" align="center" rowspan="1">
<italic>h</italic>
<sub><italic>random</italic></sub>
</th></tr><tr><th align="left" rowspan="1" colspan="1">Dataset</th><th align="left" rowspan="1" colspan="1">Value of <italic>R</italic> and <italic>K</italic>
</th><th align="left" rowspan="1" colspan="1">Average</th><th align="left" rowspan="1" colspan="1">Max.</th><th align="left" rowspan="1" colspan="1">Average</th><th align="left" rowspan="1" colspan="1">Max.</th><th align="left" rowspan="1" colspan="1">Correlation Coef.</th></tr></thead><tbody><tr><td align="left" rowspan="1" colspan="1">CAMPs</td><td align="left" rowspan="1" colspan="1">100</td><td align="char" char="." rowspan="1" colspan="1">&#x02212;0.58</td><td align="char" char="." rowspan="1" colspan="1">0.17</td><td align="char" char="." rowspan="1" colspan="1">0.76</td><td align="char" char="." rowspan="1" colspan="1">0.83</td><td align="left" rowspan="1" colspan="1">0.51</td></tr><tr><td align="left" rowspan="1" colspan="1"/><td align="left" rowspan="1" colspan="1">1000</td><td align="char" char="." rowspan="1" colspan="1">&#x02212;0.59</td><td align="char" char="." rowspan="1" colspan="1">0.18</td><td align="char" char="." rowspan="1" colspan="1">1.07</td><td align="char" char="." rowspan="1" colspan="1">1.09</td><td align="char" char="." rowspan="1" colspan="1">0.90</td></tr><tr><td align="left" rowspan="1" colspan="1">BPPs</td><td align="left" rowspan="1" colspan="1">100</td><td align="char" char="." rowspan="1" colspan="1">0.31</td><td align="char" char="." rowspan="1" colspan="1">1.39</td><td align="char" char="." rowspan="1" colspan="1">1.50</td><td align="char" char="." rowspan="1" colspan="1">2.04</td><td align="char" char="." rowspan="1" colspan="1">0.67</td></tr><tr><td align="left" rowspan="1" colspan="1"/><td align="left" rowspan="1" colspan="1">1000</td><td align="char" char="." rowspan="1" colspan="1">0.26</td><td align="char" char="." rowspan="1" colspan="1">1.36</td><td align="char" char="." rowspan="1" colspan="1">1.66</td><td align="char" char="." rowspan="1" colspan="1">2.20</td><td align="char" char="." rowspan="1" colspan="1">0.93</td></tr></tbody></table></alternatives><table-wrap-foot><p>Bioactivity comparison between the standard combinatorial screening (<italic>R</italic> random picked peptides) and the proposed approach (<italic>K</italic> best predicted peptides), initiated with the same <italic>R</italic> random peptides. Values are logarithm of bactericidal potencies. The correlation coefficients of <italic>h</italic>
<sub><italic>random</italic></sub> were computed using the oracle.</p></table-wrap-foot></table-wrap><table-wrap id="pcbi.1004074.t002" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1004074.t002</object-id><label>Table 2</label><caption><title>
<italic>In-vitro</italic> minimal inhibitory concentration assay.</title></caption><alternatives><graphic id="pcbi.1004074.t002g" xlink:href="pcbi.1004074.t002"/><table frame="box" rules="all" border="0"><colgroup span="1"><col align="left" valign="top" span="1"/><col align="left" valign="top" span="1"/><col align="left" valign="top" span="1"/><col align="left" valign="top" span="1"/><col align="left" valign="top" span="1"/><col align="left" valign="top" span="1"/></colgroup><thead><tr><th align="left" rowspan="1" colspan="1"/><th align="left" rowspan="1" colspan="1">Predicted</th><th colspan="2" align="center" rowspan="1">MIC (&#x003bc;<italic>g</italic>/<italic>ml</italic>)</th><th colspan="2" align="center" rowspan="1">Most Similar Peptide in the Training Set</th></tr><tr><th align="left" rowspan="1" colspan="1">#</th><th align="left" rowspan="1" colspan="1">Peptide Sequence</th><th align="left" rowspan="1" colspan="1">
<italic>&#x0003e;E. coli</italic>
</th><th align="left" rowspan="1" colspan="1">
<italic>S. aureus</italic>
</th><th align="left" rowspan="1" colspan="1">Peptide Sequence</th><th align="left" rowspan="1" colspan="1">% Similarity</th></tr></thead><tbody><tr><td align="left" rowspan="1" colspan="1">1</td><td align="left" rowspan="1" colspan="1">YWKKWKKLRRIFMLV</td><td align="left" rowspan="1" colspan="1">2</td><td align="left" rowspan="1" colspan="1">8</td><td align="left" rowspan="1" colspan="1">LWKLFKKIRRVLRVL</td><td align="char" char="." rowspan="1" colspan="1">40.0</td></tr><tr><td align="left" rowspan="1" colspan="1">2</td><td align="left" rowspan="1" colspan="1">WWKRWKKLRRIFLML</td><td align="left" rowspan="1" colspan="1">4</td><td align="left" rowspan="1" colspan="1">4</td><td align="left" rowspan="1" colspan="1">LWKLFKKIRRVLRVL</td><td align="char" char="." rowspan="1" colspan="1">40.0</td></tr><tr><td align="left" rowspan="1" colspan="1">3</td><td align="left" rowspan="1" colspan="1">WWKRWKRIRRIFMMV</td><td align="left" rowspan="1" colspan="1">4</td><td align="left" rowspan="1" colspan="1">8</td><td align="left" rowspan="1" colspan="1">LWKLFKKIRRVLRVL</td><td align="char" char="." rowspan="1" colspan="1">40.0</td></tr><tr><td align="left" rowspan="1" colspan="1">4</td><td align="left" rowspan="1" colspan="1">WWKWWKRLRRLFLLV</td><td align="left" rowspan="1" colspan="1">16</td><td align="left" rowspan="1" colspan="1">16</td><td align="left" rowspan="1" colspan="1">LWKLFKKIRRLLKVL</td><td align="char" char="." rowspan="1" colspan="1">46.6</td></tr><tr><td align="left" rowspan="1" colspan="1">5</td><td align="left" rowspan="1" colspan="1">KWKLFKGIRAVLKVL</td><td align="left" rowspan="1" colspan="1">4</td><td align="left" rowspan="1" colspan="1">8</td><td align="left" rowspan="1" colspan="1">-</td><td align="left" rowspan="1" colspan="1">-</td></tr><tr><td align="left" rowspan="1" colspan="1">6</td><td align="left" rowspan="1" colspan="1">GWRLIKKILRVFKGL</td><td align="left" rowspan="1" colspan="1">4</td><td align="left" rowspan="1" colspan="1">4</td><td align="left" rowspan="1" colspan="1">-</td><td align="left" rowspan="1" colspan="1">-</td></tr><tr><td align="left" rowspan="1" colspan="1">7</td><td align="left" rowspan="1" colspan="1">KWKLFLGILAVLKVL</td><td align="left" rowspan="1" colspan="1">&#x0003e; 32</td><td align="left" rowspan="1" colspan="1">&#x0003e; 32</td><td align="left" rowspan="1" colspan="1">-</td><td align="left" rowspan="1" colspan="1">-</td></tr></tbody></table></alternatives><table-wrap-foot><p>Minimal inhibitory concentration (MIC) from <italic><bold>in vitro</bold></italic> CAMPs assay. We predicted peptides 1 to 4, peptides 5 to 7 are controls from the training set. The ordering of the peptides do not reflect their predicted bioactivities.</p></table-wrap-foot></table-wrap><p>As expected, on both datasets, the number of peptides drawn (<italic>R</italic>) had no impact on the average activity of randomly drawn peptides. Also, on both datasets, increasing <italic>R</italic>, the number of random peptides, had no significant influence on the bioactivity of the best peptide found. This support the main hypothesis upon which this work is based, random peptides will consistently be of low activity. This also indicates that combinatorial chemistry alone does not allow one to find the best peptides. It requires hints to orient its search. The next paragraph points out that our machine learning approach can provide such hints.</p><p>Using the same <italic>R</italic> = 100 (low bioactivity) random peptides to initiate our method (i.e. train the predictor <italic>h</italic>
<sub><italic>random</italic></sub>), we were able to reach an antimicrobial potency of 0.83 (according to oracle, not to the prediction of <italic>h</italic>
<sub><italic>random</italic></sub>). Such antimicrobial potency is similar to the best peptide of the (unseen) CAMPs dataset and much better than the best of the <italic>R</italic> = 100 random peptides. By increasing to <italic>R</italic> to 1,000, we found a peptide having a potency of 1.09 according to the oracle. This peptide surpasses the best known peptide of the CAMPs dataset and is also far superior to the best of the <italic>R</italic> = 1,000 random peptides. On the BPPs dataset, the proposed approach also considerably outperformed the random approach on both the best peptide found and the average bioactivity. Finally, on both datasets, increasing the number of initial peptides from <italic>R</italic> = 100 to <italic>R</italic> = 1,000 was more beneficial on the bioactivity measures than the random approach.</p><p>
<bold>Comparing <italic>h</italic><sub><italic>random</italic></sub> and the oracle accuracies on the CAMPs and BPPs databases</bold> To provide additional support for its accuracy, predictor <italic>h</italic>
<sub><italic>random</italic></sub> was used to predict the bioactivity values of unseen but <italic>in-vitro</italic> validated peptides of the CAMPs and BPPs databases. The Pearson correlation coefficient (PCC, also known as the Pearson&#x02019;s <italic>r</italic>) was computed between <italic>h</italic>
<sub><italic>random</italic></sub> predictions and the values in both databases. Since, in this simulation, <italic>h</italic>
<sub><italic>random</italic></sub> was learned only with random peptides that, as pointed out above, have low bioactivity, it is interesting to evaluate its accuracy on these databases.</p><p>Correlation coefficients are shown in the last column of <xref rid="pcbi.1004074.t001" ref-type="table">Table 1</xref>. When initiated with <italic>R</italic> = 1,000 random peptides, it achieves a correlation coefficient of 0.90 (CAMPs) and 0.93 (BPP). In comparison, the oracle achieved a correlation coefficient of 0.91 (CAMPs) and 0.97 (BPP) on the same peptides. These were however used to train the oracle. Given that <italic>h</italic>
<sub><italic>random</italic></sub> is bound to be less accurate than the oracle, these results demonstrate the capability of our approach to learn a predictor using low bioactivity peptides to obtain highly active ones.</p><p>
<xref ref-type="fig" rid="pcbi.1004074.g004">Fig. 4</xref> shows the correlation coefficient of <italic>h</italic>
<sub><italic>random</italic></sub> on the CAMPs data when varying R, the number of random peptides used for training. Near optimal accuracy is reached when <italic>h</italic>
<sub><italic>random</italic></sub> is initiated with approximately <italic>R</italic> = 300 peptides. This suggests that the proposed method can achieve excellent performance with a database of modest size.</p><fig id="pcbi.1004074.g004" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1004074.g004</object-id><label>Figure 4</label><caption><title>Correlation coefficient of <italic>h</italic>
<sub><italic>random</italic></sub> predictions on the CAMPs data while varying <italic>R</italic>, the number of random peptides used as training set.</title></caption><graphic xlink:href="pcbi.1004074.g004"/></fig></sec><sec id="sec003d"><title>Binding motifs results and comparison with PSWM</title><p>The results presented here serve to demonstrate the ability of the proposed approach to predict potential functional motifs and to compare to position-specific weight matrix (PSWM) as they can be illustrated as a motif.</p><p>For the CAMPs dataset, we used <italic>h</italic>
<sub><italic>CAMP</italic></sub> as oracle and hidden all peptides in this dataset from the rest of the procedure. Using the oracle, we predicted the best <italic>K</italic> = 1,000 peptides and generated a bioactivity motif using these candidates (top panel of <xref ref-type="fig" rid="pcbi.1004074.g005">Fig. 5</xref>). Our goal was to assess how much of that reference motif we could rediscover if we were to hide all the CAMPs dataset during the validation.</p><fig id="pcbi.1004074.g005" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1004074.g005</object-id><label>Figure 5</label><caption><title>CAMP bioactivity motifs.</title><p>Top motif: the best 1,000 peptides obtained from the oracle. Middle motif: the best 1,000 peptides obtained from <italic>h</italic>
<sub><italic>random</italic></sub>. Bottom motif: the best 1,000 out of 1,000,000 random peptides.</p></caption><graphic xlink:href="pcbi.1004074.g005"/></fig><p>Using only the predictor <italic>h</italic>
<sub><italic>random</italic></sub>, trained on <italic>R</italic> = 1,000 randomly generated peptides, we generated the motif representing the <italic>K</italic> = 1,000 best predicted peptides (according to <italic>h</italic>
<sub><italic>random</italic></sub>). The motif is shown in middle panel of <xref ref-type="fig" rid="pcbi.1004074.g005">Fig. 5</xref>. We were able to recover all the reference motif signal using only weakly active peptides and <italic>h</italic>
<sub><italic>random</italic></sub>. To push the analysis even further, we also computed the motif when <italic>h</italic>
<sub><italic>random</italic></sub> is trained with only <italic>R</italic> = 100 random peptides. Even then (motif not shown), for 12 of the 15 residue positions, we were able to correctly identify the dominant amino acid property (polar, neutral, basic, acidic, hydrophobic). This can be achieved since the GS kernel encodes amino acids physico-chemical properties.</p><p>This provides evidence that the proposed approach could uncover complex signals for new, poorly understood, proteins. For example, one could learn a multi-target predictor for peptides binding to the major histocompatibility complex [<xref rid="pcbi.1004074.ref014" ref-type="bibr">14</xref>]. Since these molecules are highly polymorphic, it would be interesting to predict antigen binding motifs for a specific segment of a population or even a single patient. This would have applications in the design of epitope based vaccines [<xref rid="pcbi.1004074.ref040" ref-type="bibr">40</xref>] and provide additional insight into autoimmune diseases.</p><p>To compare our approach to PSWM, we took the same <italic>R</italic> = 1,000 randomly picked peptides used to train the predictor <italic>h</italic>
<sub><italic>random</italic></sub> and generated a PSWM. The signal in PSWM motif was very poor, generating a meaningless motif (not shown). We increased the number of random peptides to <italic>R</italic> = 1,000,000 and only selected the best <italic>K</italic> = 1,000 to produce a PSWM whose motif is shown in the bottom panel of <xref ref-type="fig" rid="pcbi.1004074.g005">Fig. 5</xref>. Despite this big advantage, the motif of the PSWM shows minimal information.</p><p>This clearly illustrates the potential of the proposed approach for accelerating the discovery of potential peptidic effectors and, possibly, for achieving a better understanding of the binding mechanisms of polymorphic molecules.</p></sec></sec><sec id="sec004"><title>Conclusion and Outlook</title><p>We proposed an efficient graph-based algorithm to predict peptides with the highest biological activity for machine learning predictors using the GS kernel. Combined with a multi-target model, it can be used to predict binding motifs for targets with no known ligands.</p><p>To increase the hit ratio of combinatorial libraries, we demonstrated how a combinatorial chemistry protocol relates to a PSWM. This allowed us to compute the expected predicted bioactivity and its variance that can be exploited in combinatorial chemistry. These steps can be part of an iterative drug discovery process that will have immediate use in both the pharmaceutical industry and academia. This methodology will reduce costs and the time to obtain lead peptides as well as facilitating their optimization. Finally, the proposed approach was validated in a real world test for the discovery of new antimicrobial peptides. These <italic>in vitro</italic> experiments confirmed the effectiveness of the new peptides uncovered.</p><p>The <italic>K</italic>-best peptides were shown to be valuable for the design of split and pool libraries. However, in such libraries, it is unclear how we should prioritize high activity candidates (average) over the chemical diversity (variance). This exploration/exploitation trade-off warrants further investigation. The fast computation of the bioactivity average and variance given a combinatorial chemistry protocol will certainly help to exploit this trade-off. Moreover, the method could easily be adapted to optimize multiple objectives simultaneously, for example, the bioactivity at the expense of mammalian cell toxicity or bioavailability when such data are available. In addition, the method could be expanded to cyclic peptides and chemical entities commonly found in clinical compounds. Finally, this method shows great promise in immunology, where antigen binding motifs for unstudied major histocompatibility complexes could be uncovered using a multi-target predictor.</p></sec><sec sec-type="supplementary-material" id="sec005"><title>Supporting Information</title><supplementary-material content-type="local-data" id="pcbi.1004074.s001"><label>S1 Text</label><caption><title>Supplementary material.</title><p>(PDF)</p></caption><media xlink:href="pcbi.1004074.s001.pdf"><caption><p>Click here for additional data file.</p></caption></media></supplementary-material></sec></body><back><ack><p>The authors thank Pascal Germain for his insightful comments.</p></ack><ref-list><title>References</title><ref id="pcbi.1004074.ref001"><label>1</label><mixed-citation publication-type="journal">
<name><surname>Mee</surname><given-names>R</given-names></name>, <name><surname>Auton</surname><given-names>T</given-names></name>, <name><surname>Morgan</surname><given-names>P</given-names></name> (<year>1997</year>) <article-title>Design of active analogues of a 15-residue peptide using d-optimal design, qsar and a combinatorial search algorithm</article-title>. <source>The Journal of peptide research</source>
<volume>49</volume>: <fpage>89</fpage>&#x02013;<lpage>102</lpage>. <pub-id pub-id-type="doi">10.1111/j.1399-3011.1997.tb01125.x</pub-id>
<?supplied-pmid 9128105?><pub-id pub-id-type="pmid">9128105</pub-id></mixed-citation></ref><ref id="pcbi.1004074.ref002"><label>2</label><mixed-citation publication-type="journal">
<name><surname>Furka</surname><given-names>A</given-names></name>, <name><surname>SEBESTY&#x000c9;N</surname><given-names>F</given-names></name>, <name><surname>ASGEDOM</surname><given-names>M</given-names></name>, <name><surname>DIB&#x000d3;</surname><given-names>G</given-names></name> (<year>1991</year>) <article-title>General method for rapid synthesis of multicomponent peptide mixtures</article-title>. <source>International journal of peptide and protein research</source>
<volume>37</volume>: <fpage>487</fpage>&#x02013;<lpage>493</lpage>. <pub-id pub-id-type="doi">10.1111/j.1399-3011.1991.tb00765.x</pub-id>
<?supplied-pmid 1917305?><pub-id pub-id-type="pmid">1917305</pub-id></mixed-citation></ref><ref id="pcbi.1004074.ref003"><label>3</label><mixed-citation publication-type="journal">
<name><surname>Houghten</surname><given-names>RA</given-names></name>, <name><surname>Pinilla</surname><given-names>C</given-names></name>, <name><surname>Blondelle</surname><given-names>SE</given-names></name>, <name><surname>Appel</surname><given-names>JR</given-names></name>, <name><surname>Dooley</surname><given-names>CT</given-names></name>, <etal>et al</etal> (<year>1991</year>) <article-title>Generation and use of synthetic peptide combinatorial libraries for basic research and drug discovery</article-title>. <source>Nature</source>
<volume>354</volume>: <fpage>84</fpage>&#x02013;<lpage>86</lpage>. <pub-id pub-id-type="doi">10.1038/354084a0</pub-id>
<?supplied-pmid 1719428?><pub-id pub-id-type="pmid">1719428</pub-id></mixed-citation></ref><ref id="pcbi.1004074.ref004"><label>4</label><mixed-citation publication-type="journal">
<name><surname>Lam</surname><given-names>KS</given-names></name>, <name><surname>Salmon</surname><given-names>SE</given-names></name>, <name><surname>Hersh</surname><given-names>EM</given-names></name>, <name><surname>Hruby</surname><given-names>VJ</given-names></name>, <name><surname>Kazmierski</surname><given-names>WM</given-names></name>, <etal>et al</etal> (<year>1991</year>) <article-title>A new type of synthetic peptide library for identifying ligand-binding activity</article-title>. <source>Nature</source>
<volume>354</volume>: <fpage>82</fpage>&#x02013;<lpage>84</lpage>. <pub-id pub-id-type="doi">10.1038/354082a0</pub-id>
<?supplied-pmid 1944576?><pub-id pub-id-type="pmid">1944576</pub-id></mixed-citation></ref><ref id="pcbi.1004074.ref005"><label>5</label><mixed-citation publication-type="journal">
<name><surname>Latacz</surname><given-names>G</given-names></name>, <name><surname>Pekala</surname><given-names>E</given-names></name>, <name><surname>Ciopinska</surname><given-names>A</given-names></name>, <name><surname>Kiec-Kononowicz</surname><given-names>K</given-names></name> (<year>2006</year>) <article-title>Unnatural d-amino acids as building blocks of new peptidomimetics</article-title>. <source>Acta Poloniae Pharmaceutica&#x02013;Drug Research</source>
<volume>62</volume>: <fpage>430</fpage>&#x02013;<lpage>433</lpage>.</mixed-citation></ref><ref id="pcbi.1004074.ref006"><label>6</label><mixed-citation publication-type="journal">
<name><surname>Rush</surname><given-names>TS</given-names></name>, <name><surname>Grant</surname><given-names>JA</given-names></name>, <name><surname>Mosyak</surname><given-names>L</given-names></name>, <name><surname>Nicholls</surname><given-names>A</given-names></name> (<year>2005</year>) <article-title>A shape-based 3-d sca old hopping method and its application to a bacterial protein-protein interaction</article-title>. <source>Journal of medicinal chemistry</source>
<volume>48</volume>: <fpage>1489</fpage>&#x02013;<lpage>1495</lpage>. <pub-id pub-id-type="doi">10.1021/jm040163o</pub-id>
<?supplied-pmid 15743191?><pub-id pub-id-type="pmid">15743191</pub-id></mixed-citation></ref><ref id="pcbi.1004074.ref007"><label>7</label><mixed-citation publication-type="journal">
<name><surname>Lam</surname><given-names>KS</given-names></name>, <name><surname>Lebl</surname><given-names>M</given-names></name>, <name><surname>Krchn&#x000e1;k</surname><given-names>V</given-names></name> (<year>1997</year>) <article-title>The one-bead-one-compound combinatorial library method</article-title>. <source>Chemical reviews</source>
<volume>97</volume>: <fpage>411</fpage>&#x02013;<lpage>448</lpage>. <pub-id pub-id-type="doi">10.1021/cr9600114</pub-id>
<?supplied-pmid 11848877?><pub-id pub-id-type="pmid">11848877</pub-id></mixed-citation></ref><ref id="pcbi.1004074.ref008"><label>8</label><mixed-citation publication-type="book">
<name><surname>Shawe-Taylor</surname><given-names>J</given-names></name>, <name><surname>Cristianini</surname><given-names>N</given-names></name> (<year>2004</year>) <source>Kernel methods for pattern analysis</source>. <publisher-name>Cambridge university press</publisher-name>.</mixed-citation></ref><ref id="pcbi.1004074.ref009"><label>9</label><mixed-citation publication-type="journal">
<name><surname>Swamidass</surname><given-names>SJ</given-names></name>, <name><surname>Chen</surname><given-names>J</given-names></name>, <name><surname>Bruand</surname><given-names>J</given-names></name>, <name><surname>Phung</surname><given-names>P</given-names></name>, <name><surname>Ralaivola</surname><given-names>L</given-names></name>, <etal>et al</etal> (<year>2005</year>) <article-title>Kernels for small molecules and the prediction of mutagenicity, toxicity and anti-cancer activity</article-title>. <source>Bioinformatics</source>
<volume>21</volume>: <fpage>i359</fpage>&#x02013;<lpage>i368</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/bti1055</pub-id>
<?supplied-pmid 15961479?><pub-id pub-id-type="pmid">15961479</pub-id></mixed-citation></ref><ref id="pcbi.1004074.ref010"><label>10</label><mixed-citation publication-type="journal">
<name><surname>Jacob</surname><given-names>L</given-names></name>, <name><surname>Hoffmann</surname><given-names>B</given-names></name>, <name><surname>Stoven</surname><given-names>V</given-names></name>, <name><surname>Vert</surname><given-names>JP</given-names></name> (<year>2008</year>) <article-title>Virtual screening of gpcrs: an in silico chemogenomics approach</article-title>. <source>BMC bioinformatics</source>
<volume>9</volume>: <fpage>363</fpage>
<pub-id pub-id-type="doi">10.1186/1471-2105-9-363</pub-id>
<?supplied-pmid 18775075?><pub-id pub-id-type="pmid">18775075</pub-id></mixed-citation></ref><ref id="pcbi.1004074.ref011"><label>11</label><mixed-citation publication-type="journal">
<name><surname>Ben-Hur</surname><given-names>A</given-names></name>, <name><surname>Noble</surname><given-names>WS</given-names></name> (<year>2005</year>) <article-title>Kernel methods for predicting protein-protein interactions</article-title>. <source>Bioinformatics</source>
<volume>21</volume>: <fpage>i38</fpage>&#x02013;<lpage>i46</lpage>.<pub-id pub-id-type="pmid">15961482</pub-id></mixed-citation></ref><ref id="pcbi.1004074.ref012"><label>12</label><mixed-citation publication-type="journal">
<name><surname>Schneider</surname><given-names>G</given-names></name> (<year>2010</year>) <article-title>Virtual screening: an endless staircase?</article-title>
<source>Nature Reviews Drug Discovery</source>
<volume>9</volume>: <fpage>273</fpage>&#x02013;<lpage>276</lpage>. <pub-id pub-id-type="doi">10.1038/nrd3139</pub-id>
<?supplied-pmid 20357802?><pub-id pub-id-type="pmid">20357802</pub-id></mixed-citation></ref><ref id="pcbi.1004074.ref013"><label>13</label><mixed-citation publication-type="journal">
<name><surname>Damborsky</surname><given-names>J</given-names></name>, <name><surname>Brezovsky</surname><given-names>J</given-names></name> (<year>2009</year>) <article-title>Computational tools for designing and engineering biocatalysts</article-title>. <source>Current opinion in chemical biology</source>
<volume>13</volume>: <fpage>26</fpage>&#x02013;<lpage>34</lpage>. <pub-id pub-id-type="doi">10.1016/j.cbpa.2009.02.021</pub-id>
<?supplied-pmid 19297237?><pub-id pub-id-type="pmid">19297237</pub-id></mixed-citation></ref><ref id="pcbi.1004074.ref014"><label>14</label><mixed-citation publication-type="journal">
<name><surname>Gigu&#x000e8;re</surname><given-names>S</given-names></name>, <name><surname>Marchand</surname><given-names>M</given-names></name>, <name><surname>Laviolette</surname><given-names>F</given-names></name>, <name><surname>Drouin</surname><given-names>A</given-names></name>, <name><surname>Corbeil</surname><given-names>J</given-names></name> (<year>2013</year>) <article-title>Learning a peptide-protein binding affinity predictor with kernel ridge regression</article-title>. <source>BMC Bioinformatics</source>
<volume>14</volume>
<pub-id pub-id-type="doi">10.1186/1471-2105-14-82</pub-id>
<?supplied-pmid 23497081?><pub-id pub-id-type="pmid">23497081</pub-id></mixed-citation></ref><ref id="pcbi.1004074.ref015"><label>15</label><mixed-citation publication-type="journal">
<name><surname>Saigo</surname><given-names>H</given-names></name>, <name><surname>Vert</surname><given-names>JP</given-names></name>, <name><surname>Ueda</surname><given-names>N</given-names></name>, <name><surname>Akutsu</surname><given-names>T</given-names></name> (<year>2004</year>) <article-title>Protein homology detection using string alignment kernels</article-title>. <source>Bioinformatics</source>
<volume>20</volume>: <fpage>1682</fpage>&#x02013;<lpage>1689</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/bth141</pub-id>
<?supplied-pmid 14988126?><pub-id pub-id-type="pmid">14988126</pub-id></mixed-citation></ref><ref id="pcbi.1004074.ref016"><label>16</label><mixed-citation publication-type="book">
<name><surname>Leslie</surname><given-names>CS</given-names></name>, <name><surname>Eskin</surname><given-names>E</given-names></name>, <name><surname>Noble</surname><given-names>WS</given-names></name> (<year>2002</year>) <article-title>The spectrum kernel: A string kernel for svm protein classification</article-title>. In: <source>Pacific symposium on biocomputing</source>. <publisher-name>World Scientific</publisher-name>, <volume>volume 7</volume>, pp. <fpage>566</fpage>&#x02013;<lpage>575</lpage>.</mixed-citation></ref><ref id="pcbi.1004074.ref017"><label>17</label><mixed-citation publication-type="journal">
<name><surname>Meinicke</surname><given-names>P</given-names></name>, <name><surname>Tech</surname><given-names>M</given-names></name>, <name><surname>Morgenstern</surname><given-names>B</given-names></name>, <name><surname>Merkl</surname><given-names>R</given-names></name> (<year>2004</year>) <article-title>Oligo kernels for datamining on biological sequences: A case study on prokaryotic translation initiation sites</article-title>. <source>BMC Bioinformatics</source>
<volume>5</volume>
<pub-id pub-id-type="doi">10.1186/1471-2105-5-169</pub-id>
<?supplied-pmid 15511290?><pub-id pub-id-type="pmid">15511290</pub-id></mixed-citation></ref><ref id="pcbi.1004074.ref018"><label>18</label><mixed-citation publication-type="journal">
<name><surname>Toussaint</surname><given-names>N</given-names></name>, <name><surname>Widmer</surname><given-names>C</given-names></name>, <name><surname>Kohlbacher</surname><given-names>O</given-names></name>, <name><surname>R&#x000e4;tsch</surname><given-names>G</given-names></name> (<year>2010</year>) <article-title>Exploiting physico-chemical properties in string kernels</article-title>. <source>BMC bioinformatics</source>
<volume>11</volume>: <fpage>S7</fpage>
<pub-id pub-id-type="doi">10.1186/1471-2105-11-S8-S7</pub-id>
<?supplied-pmid 21034432?><pub-id pub-id-type="pmid">21034432</pub-id></mixed-citation></ref><ref id="pcbi.1004074.ref019"><label>19</label><mixed-citation publication-type="book">
<name><surname>R&#x000e4;tsch</surname><given-names>G</given-names></name>, <name><surname>Sonnenburg</surname><given-names>S</given-names></name> (<year>2004</year>) <article-title>Accurate Splice Site Detection for Caenorhabditis elegans</article-title>. In: <name><surname>Vert JP</surname><given-names>B</given-names></name>, editors, <source>Kernel Methods in Computational Biology</source>, <publisher-name>MIT Press</publisher-name> pp. <fpage>277</fpage>&#x02013;<lpage>298</lpage>.</mixed-citation></ref><ref id="pcbi.1004074.ref020"><label>20</label><mixed-citation publication-type="journal">
<name><surname>Gigu&#x000e8;re</surname><given-names>S</given-names></name>, <name><surname>Drouin</surname><given-names>A</given-names></name>, <name><surname>Lacoste</surname><given-names>A</given-names></name>, <name><surname>Marchand</surname><given-names>M</given-names></name>, <name><surname>Corbeil</surname><given-names>J</given-names></name>, <etal>et al</etal> (<year>2013</year>) <article-title>Mhc-np: Predicting peptides naturally processed by the mhc</article-title>. <source>Journal of Immunological Methods</source>.
<?supplied-pmid 24144535?><pub-id pub-id-type="pmid">24144535</pub-id></mixed-citation></ref><ref id="pcbi.1004074.ref021"><label>21</label><mixed-citation publication-type="book">
<name><surname>Baldi</surname><given-names>P</given-names></name>, <name><surname>Brunak</surname><given-names>S</given-names></name> (<year>2001</year>) <source>Bioinformatics: the machine learning approach</source>. <publisher-name>MIT press</publisher-name>.</mixed-citation></ref><ref id="pcbi.1004074.ref022"><label>22</label><mixed-citation publication-type="journal">
<name><surname>Mordelet</surname><given-names>F</given-names></name>, <name><surname>Horton</surname><given-names>J</given-names></name>, <name><surname>Hartemink</surname><given-names>AJ</given-names></name>, <name><surname>Engelhardt</surname><given-names>BE</given-names></name>, <name><surname>Gord&#x000e2;n</surname><given-names>R</given-names></name> (<year>2013</year>) <article-title>Stability selection for regression-based models of transcription factor&#x02013;dna binding specificity</article-title>. <source>Bioinformatics</source>
<volume>29</volume>: <fpage>i117</fpage>&#x02013;<lpage>i125</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btt221</pub-id>
<?supplied-pmid 23812975?><pub-id pub-id-type="pmid">23812975</pub-id></mixed-citation></ref><ref id="pcbi.1004074.ref023"><label>23</label><mixed-citation publication-type="journal">
<name><surname>Dyrl&#x000f8;v Bendtsen</surname><given-names>J</given-names></name>, <name><surname>Nielsen</surname><given-names>H</given-names></name>, <name><surname>von Heijne</surname><given-names>G</given-names></name>, <name><surname>Brunak</surname><given-names>S</given-names></name> (<year>2004</year>) <article-title>Improved prediction of signal peptides: Signalp 3.0</article-title>. <source>Journal of molecular biology</source>
<volume>340</volume>: <fpage>783</fpage>&#x02013;<lpage>795</lpage>. <pub-id pub-id-type="doi">10.1016/j.jmb.2004.05.028</pub-id>
<pub-id pub-id-type="pmid">15223320</pub-id></mixed-citation></ref><ref id="pcbi.1004074.ref024"><label>24</label><mixed-citation publication-type="journal">
<name><surname>Jamois</surname><given-names>EA</given-names></name> (<year>2003</year>) <article-title>Reagent-based and product-based computational approaches in library design</article-title>. <source>Current opinion in chemical biology</source>
<volume>7</volume>: <fpage>326</fpage>&#x02013;<lpage>330</lpage>. <pub-id pub-id-type="doi">10.1016/S1367-5931(03)00053-X</pub-id>
<?supplied-pmid 12826119?><pub-id pub-id-type="pmid">12826119</pub-id></mixed-citation></ref><ref id="pcbi.1004074.ref025"><label>25</label><mixed-citation publication-type="journal">
<name><surname>Pickett</surname><given-names>SD</given-names></name>, <name><surname>McLay</surname><given-names>IM</given-names></name>, <name><surname>Clark</surname><given-names>DE</given-names></name> (<year>2000</year>) <article-title>Enhancing the hit-to-lead properties of lead optimization libraries</article-title>. <source>Journal of chemical information and computer sciences</source>
<volume>40</volume>: <fpage>263</fpage>&#x02013;<lpage>272</lpage>.
<?supplied-pmid 10761127?><pub-id pub-id-type="pmid">10761127</pub-id></mixed-citation></ref><ref id="pcbi.1004074.ref026"><label>26</label><mixed-citation publication-type="journal">
<name><surname>Yen</surname><given-names>JY</given-names></name> (<year>1971</year>) <article-title>Finding the k shortest loopless paths in a network</article-title>. <source>management Science</source>
<volume>17</volume>: <fpage>712</fpage>&#x02013;<lpage>716</lpage>. <pub-id pub-id-type="doi">10.1287/mnsc.17.11.712</pub-id>
</mixed-citation></ref><ref id="pcbi.1004074.ref027"><label>27</label><mixed-citation publication-type="journal">
<name><surname>Lawler</surname><given-names>EL</given-names></name> (<year>1972</year>) <article-title>A procedure for computing the k best solutions to discrete optimization problems and its application to the shortest path problem</article-title>. <source>Management Science</source>
<volume>18</volume>: <fpage>401</fpage>&#x02013;<lpage>405</lpage>. <pub-id pub-id-type="doi">10.1287/mnsc.18.7.401</pub-id>
</mixed-citation></ref><ref id="pcbi.1004074.ref028"><label>28</label><mixed-citation publication-type="other">Brander AW, Sinclair MC (1995) A comparative study of k-shortest path algorithms. Ph.D. thesis, Citeseer.</mixed-citation></ref><ref id="pcbi.1004074.ref029"><label>29</label><mixed-citation publication-type="journal">
<name><surname>Eppstein</surname><given-names>D</given-names></name> (<year>1998</year>) <article-title>Finding the k shortest paths</article-title>. <source>SIAM Journal on computing</source>
<volume>28</volume>: <fpage>652</fpage>&#x02013;<lpage>673</lpage>. <pub-id pub-id-type="doi">10.1137/S0097539795290477</pub-id>
</mixed-citation></ref><ref id="pcbi.1004074.ref030"><label>30</label><mixed-citation publication-type="journal">
<name><surname>Kumaresan</surname><given-names>PR</given-names></name>, <name><surname>Wang</surname><given-names>Y</given-names></name>, <name><surname>Saunders</surname><given-names>M</given-names></name>, <name><surname>Maeda</surname><given-names>Y</given-names></name>, <name><surname>Liu</surname><given-names>R</given-names></name>, <etal>et al</etal> (<year>2011</year>) <article-title>Rapid discovery of death ligands with one-bead-two-compound combinatorial library methods</article-title>. <source>ACS combinatorial science</source>
<volume>13</volume>: <fpage>259</fpage>&#x02013;<lpage>264</lpage>. <pub-id pub-id-type="doi">10.1021/co100069t</pub-id>
<?supplied-pmid 21302937?><pub-id pub-id-type="pmid">21302937</pub-id></mixed-citation></ref><ref id="pcbi.1004074.ref031"><label>31</label><mixed-citation publication-type="journal">
<name><surname>Liu</surname><given-names>T</given-names></name>, <name><surname>Joo</surname><given-names>SH</given-names></name>, <name><surname>Voorhees</surname><given-names>JL</given-names></name>, <name><surname>Brooks</surname><given-names>CL</given-names></name>, <name><surname>Pei</surname><given-names>D</given-names></name> (<year>2009</year>) <article-title>Synthesis and screening of a cyclic peptide library: discovery of small-molecule ligands against human prolactin receptor</article-title>. <source>Bioorganic &#x00026; medicinal chemistry</source>
<volume>17</volume>: <fpage>1026</fpage>&#x02013;<lpage>1033</lpage>. <pub-id pub-id-type="doi">10.1016/j.bmc.2008.01.015</pub-id>
<pub-id pub-id-type="pmid">18234500</pub-id></mixed-citation></ref><ref id="pcbi.1004074.ref032"><label>32</label><mixed-citation publication-type="journal">
<name><surname>Alluri</surname><given-names>PG</given-names></name>, <name><surname>Reddy</surname><given-names>MM</given-names></name>, <name><surname>Bachhawat-Sikder</surname><given-names>K</given-names></name>, <name><surname>Olivos</surname><given-names>HJ</given-names></name>, <name><surname>Kodadek</surname><given-names>T</given-names></name> (<year>2003</year>) <article-title>Isolation of protein ligands from large peptoid libraries</article-title>. <source>Journal of the American Chemical Society</source>
<volume>125</volume>: <fpage>13995</fpage>&#x02013;<lpage>14004</lpage>. <pub-id pub-id-type="doi">10.1021/ja036417x</pub-id>
<?supplied-pmid 14611236?><pub-id pub-id-type="pmid">14611236</pub-id></mixed-citation></ref><ref id="pcbi.1004074.ref033"><label>33</label><mixed-citation publication-type="journal">
<name><surname>Joo</surname><given-names>SH</given-names></name>, <name><surname>Pei</surname><given-names>D</given-names></name> (<year>2008</year>) <article-title>Synthesis and screening of support-bound combinatorial peptide libraries with free c-termini: Determination of the sequence specificity of pdz domains</article-title>. <source>Biochemistry</source>
<volume>47</volume>: <fpage>3061</fpage>&#x02013;<lpage>3072</lpage>. <pub-id pub-id-type="doi">10.1021/bi7023628</pub-id>
<?supplied-pmid 18232644?><pub-id pub-id-type="pmid">18232644</pub-id></mixed-citation></ref><ref id="pcbi.1004074.ref034"><label>34</label><mixed-citation publication-type="journal">
<name><surname>Mart&#x000ed;nez-Ceron</surname><given-names>MC</given-names></name>, <name><surname>Marani</surname><given-names>MM</given-names></name>, <name><surname>Taul&#x000e9;s</surname><given-names>M</given-names></name>, <name><surname>Etcheverrigaray</surname><given-names>M</given-names></name>, <name><surname>Albericio</surname><given-names>F</given-names></name>, <etal>et al</etal> (<year>2011</year>) <article-title>Affinity chromatography based on a combinatorial strategy for rerythropoietin purification</article-title>. <source>ACS combinatorial science</source>
<volume>13</volume>: <fpage>251</fpage>&#x02013;<lpage>258</lpage>. <pub-id pub-id-type="doi">10.1021/co1000663</pub-id>
<?supplied-pmid 21495625?><pub-id pub-id-type="pmid">21495625</pub-id></mixed-citation></ref><ref id="pcbi.1004074.ref035"><label>35</label><mixed-citation publication-type="journal">
<name><surname>Zhang</surname><given-names>Y</given-names></name>, <name><surname>Zhou</surname><given-names>S</given-names></name>, <name><surname>Wavreille</surname><given-names>AS</given-names></name>, <name><surname>DeWille</surname><given-names>J</given-names></name>, <name><surname>Pei</surname><given-names>D</given-names></name> (<year>2008</year>) <article-title>Cyclic peptidyl inhibitors of grb2 and tensin sh2 domains identified from combinatorial libraries</article-title>. <source>Journal of combinatorial chemistry</source>
<volume>10</volume>: <fpage>247</fpage>&#x02013;<lpage>255</lpage>. <pub-id pub-id-type="doi">10.1021/cc700185g</pub-id>
<?supplied-pmid 18257540?><pub-id pub-id-type="pmid">18257540</pub-id></mixed-citation></ref><ref id="pcbi.1004074.ref036"><label>36</label><mixed-citation publication-type="journal">
<name><surname>Liu</surname><given-names>T</given-names></name>, <name><surname>Qian</surname><given-names>Z</given-names></name>, <name><surname>Xiao</surname><given-names>Q</given-names></name>, <name><surname>Pei</surname><given-names>D</given-names></name> (<year>2011</year>) <article-title>High-throughput screening of one-bead-one-compound libraries: identification of cyclic peptidyl inhibitors against calcineurin/nfat interaction</article-title>. <source>ACS combinatorial science</source>
<volume>13</volume>: <fpage>537</fpage>&#x02013;<lpage>546</lpage>. <pub-id pub-id-type="doi">10.1021/co200101w</pub-id>
<?supplied-pmid 21848276?><pub-id pub-id-type="pmid">21848276</pub-id></mixed-citation></ref><ref id="pcbi.1004074.ref037"><label>37</label><mixed-citation publication-type="journal">
<name><surname>Alluri</surname><given-names>P</given-names></name>, <name><surname>Liu</surname><given-names>B</given-names></name>, <name><surname>Yu</surname><given-names>P</given-names></name>, <name><surname>Xiao</surname><given-names>X</given-names></name>, <name><surname>Kodadek</surname><given-names>T</given-names></name> (<year>2006</year>) <article-title>Isolation and characterization of coactivator-binding peptoids from a combinatorial library</article-title>. <source>Molecular BioSystems</source>
<volume>2</volume>: <fpage>568</fpage>&#x02013;<lpage>579</lpage>. <pub-id pub-id-type="doi">10.1039/b608924k</pub-id>
<?supplied-pmid 17216038?><pub-id pub-id-type="pmid">17216038</pub-id></mixed-citation></ref><ref id="pcbi.1004074.ref038"><label>38</label><mixed-citation publication-type="journal">
<name><surname>Wade</surname><given-names>D</given-names></name>, <name><surname>Englund</surname><given-names>J</given-names></name> (<year>2002</year>) <article-title>Synthetic antibiotic peptides database</article-title>. <source>Protein and peptide letters</source>
<volume>9</volume>: <fpage>53</fpage>&#x02013;<lpage>57</lpage>. <pub-id pub-id-type="doi">10.2174/0929866023408986</pub-id>
<?supplied-pmid 12141924?><pub-id pub-id-type="pmid">12141924</pub-id></mixed-citation></ref><ref id="pcbi.1004074.ref039"><label>39</label><mixed-citation publication-type="journal">
<name><surname>Ufkes</surname><given-names>JG</given-names></name>, <name><surname>Visser</surname><given-names>BJ</given-names></name>, <name><surname>Heuver</surname><given-names>G</given-names></name>, <name><surname>Wynne</surname><given-names>HJ</given-names></name>, <name><surname>Meer</surname><given-names>CVD</given-names></name> (<year>1982</year>) <article-title>Further studies on the structure-activity relationships of bradykinin-potentiating peptides</article-title>. <source>European Journal of Pharmacology</source>
<volume>79</volume>: <fpage>155</fpage>&#x02013;<lpage>158</lpage>. <pub-id pub-id-type="doi">10.1016/0014-2999(82)90590-8</pub-id>
<?supplied-pmid 7084307?><pub-id pub-id-type="pmid">7084307</pub-id></mixed-citation></ref><ref id="pcbi.1004074.ref040"><label>40</label><mixed-citation publication-type="journal">
<name><surname>Toussaint</surname><given-names>NC</given-names></name>, <name><surname>Kohlbacher</surname><given-names>O</given-names></name> (<year>2009</year>) <article-title>Towards in silico design of epitope-based vaccines</article-title>. <source>Expert Opinion on Drug Discovery</source>. <pub-id pub-id-type="doi">10.1517/17460440903242283</pub-id>
<?supplied-pmid 23480396?><pub-id pub-id-type="pmid">23480396</pub-id></mixed-citation></ref></ref-list></back></article>