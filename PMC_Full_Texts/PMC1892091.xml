<!DOCTYPE article PUBLIC "-//NLM//DTD Journal Archiving and Interchange DTD v2.3 20070202//EN" "archivearticle.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article"><front><journal-meta><journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id><journal-title>BMC Bioinformatics</journal-title><issn pub-type="epub">1471-2105</issn><publisher><publisher-name>BioMed Central</publisher-name><publisher-loc>London</publisher-loc></publisher></journal-meta><article-meta><article-id pub-id-type="pmcid">1892091</article-id><article-id pub-id-type="publisher-id">1471-2105-8-S5-S3</article-id><article-id pub-id-type="doi">10.1186/1471-2105-8-S5-S3</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research</subject></subj-group></article-categories><title-group><article-title>Learning biophysically-motivated parameters for alpha helix prediction</article-title></title-group><contrib-group><contrib id="A1" corresp="yes" contrib-type="author"><name><surname>Gassend</surname><given-names>Blaise</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>gassend@mit.edu</email></contrib><contrib id="A2" corresp="yes" contrib-type="author"><name><surname>O'Donnell</surname><given-names>Charles W</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>cwo@mit.edu</email></contrib><contrib id="A3" corresp="yes" contrib-type="author"><name><surname>Thies</surname><given-names>William</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>thies@mit.edu</email></contrib><contrib id="A4" contrib-type="author"><name><surname>Lee</surname><given-names>Andrew</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>lee@mit.edu</email></contrib><contrib id="A5" contrib-type="author"><name><surname>van Dijk</surname><given-names>Marten</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>marten@mit.edu</email></contrib><contrib id="A6" contrib-type="author"><name><surname>Devadas</surname><given-names>Srinivas</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>devadas@mit.edu</email></contrib></contrib-group><aff id="I1"><label>1</label>Computer Science and Artificial Intelligence Laboratory, Massachusetts Institute of Technology, Cambridge, Massachusetts, USA</aff><pub-date pub-type="collection"><year>2007</year></pub-date><pub-date pub-type="epub"><day>24</day><month>5</month><year>2007</year></pub-date><volume>8</volume><issue>Suppl 5</issue><supplement><named-content content-type="supplement-title">Articles selected from posters presented at the Tenth Annual International Conference on Research in Computational Biology</named-content><named-content content-type="supplement-editor">Alberto Apostolico, Raffaele Giancarlo, Concettina Guerra and Giuseppe Lancia</named-content></supplement><fpage>S3</fpage><lpage>S3</lpage><ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/8/S5/S3"/><permissions><copyright-statement>Copyright &#x000a9; 2007 Gassend et al; licensee BioMed Central Ltd.</copyright-statement><copyright-year>2007</copyright-year><copyright-holder>Gassend et al; licensee BioMed Central Ltd.</copyright-holder><license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0"><p>This is an open access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0"/>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</p><!--<rdf xmlns="http://web.resource.org/cc/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:dcterms="http://purl.org/dc/terms"><Work xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" rdf:about=""><license rdf:resource="http://creativecommons.org/licenses/by/2.0"/><dc:type rdf:resource="http://purl.org/dc/dcmitype/Text"/><dc:author>
               Gassend
               Blaise
               
               gassend@mit.edu
            </dc:author><dc:title>
            Learning biophysically-motivated parameters for alpha helix prediction
         </dc:title><dc:date>2007</dc:date><dcterms:bibliographicCitation>BMC Bioinformatics 8(Suppl 5): S3-. (2007)</dcterms:bibliographicCitation><dc:identifier type="sici">1471-2105(2007)8:Suppl 5&#x0003c;S3&#x0003e;</dc:identifier><dcterms:isPartOf>urn:ISSN:1471-2105</dcterms:isPartOf><License rdf:about="http://creativecommons.org/licenses/by/2.0"><permits rdf:resource="http://web.resource.org/cc/Reproduction" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/Distribution" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Notice" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Attribution" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" xmlns=""/></License></Work></rdf>--></license></permissions><abstract><sec><title>Background</title><p>Our goal is to develop a state-of-the-art protein secondary structure predictor, with an intuitive and biophysically-motivated energy model. We treat structure prediction as an optimization problem, using parameterizable cost functions representing biological "pseudo-energies". Machine learning methods are applied to estimate the values of the parameters to correctly predict known protein structures.</p></sec><sec><title>Results</title><p>Focusing on the prediction of alpha helices in proteins, we show that a model with 302 parameters can achieve a Q<sub><italic>&#x003b1; </italic></sub>value of 77.6% and an SOV<sub><italic>&#x003b1; </italic></sub>value of 73.4%. Such performance numbers are among the best for techniques that do not rely on external databases (such as multiple sequence alignments). Further, it is easier to extract biological significance from a model with so few parameters.</p></sec><sec><title>Conclusion</title><p>The method presented shows promise for the prediction of protein secondary structure. Biophysically-motivated elementary free-energies can be learned using SVM techniques to construct an energy cost function whose predictive performance rivals state-of-the-art. This method is general and can be extended beyond the all-alpha case described here.</p></sec></abstract><conference><conf-date>2&#x02013;5 April 2006</conf-date><conf-name>The Tenth Annual International Conference on Research in Computational Biology</conf-name><conf-loc>Venice, Italy</conf-loc></conference></article-meta></front><body><sec><title>Background</title><p>It remains an important and relevant problem to accurately predict the secondary structure of proteins based on their amino acid sequence. The identification of basic secondary structure elements &#x02013; alpha helices, beta strands, and coils &#x02013; is a critical prerequisite for many tertiary structure predictors, which consider the complete three-dimensional protein structure. To date, there has been a broad array of approaches to secondary structure prediction, including statistical techniques, neural networks, hidden Markov models, support vector machines, nearest neighbor methods and energy minimization. In terms of prediction accuracy, neural networks are among the most popular methods in use today [<xref ref-type="bibr" rid="B1">1</xref>,<xref ref-type="bibr" rid="B2">2</xref>], delivering a pointwise prediction accuracy (Q<sub>3</sub>) of about 77% and a segment overlap measure (SOV) [<xref ref-type="bibr" rid="B3">3</xref>] of about 74% [<xref ref-type="bibr" rid="B4">4</xref>].</p><p>However, to improve the long-term performance of secondary structure prediction, it likely will be necessary to develop a cost model that mirrors the underlying biological constraints. While neural networks offer good performance today, their operation is largely opaque. Often containing up to 10,000 parameters and relying on complex layers of non-linear perceptrons, neural networks offer little insight into the patterns learned. Moreover, they mask the shortcomings of the underlying models, rendering it a tedious and ad-hoc process to improve them. In fact, in the past 15 years, the largest improvements in neural network prediction accuracy have been due to the integration of homologous sequence alignments [<xref ref-type="bibr" rid="B4">4</xref>] rather than specific changes to the underlying cost model.</p><p>In our approach we focus on simpler, more natural cost models that are based on the underlying biophysics. Due to the lack of experimentally determined free energy values, we begin with parameterizable cost functions, and treat parameter value estimation as an optimization problem. Our goal is then to determine the values of these "pseudo-energies" such that they correctly predict known protein structures. An iterative constraint-based optimization method is used to do this machine learning, incorporating the power of Support Vector Machines (SVMs).</p><p>Using a cost function based on Hidden Markov Models (HMMs), we develop a secondary structure predictor for all-alpha proteins. With only 302 parameters, representing the energetic benefit for each residue being in a helix or being a certain distance from the N- or C-cap, our predictor achieves a Q<sub><italic>&#x003b1; </italic></sub>value of 77.6% and a SOV<sub><italic>&#x003b1; </italic></sub>score of 73.4% when applied to a database of all-alpha proteins. Our technique does not depend on any homologous sequence alignments. When compared to other methods that do not utilize alignment information, it appears that our Q<sub><italic>&#x003b1; </italic></sub>represents a 3.5% improvement of the previous best [<xref ref-type="bibr" rid="B5">5</xref>], while our SOV<sub><italic>&#x003b1; </italic></sub>is comparable (0.2% better). However, due to differences in the data set, we emphasize the novelty of the approach rather than the exact magnitude of the improvements. We are extending our technique to beta strands (and associated data sets) as ongoing work.</p><sec><title>Related work</title><p>King and Sternberg share our goal of identifying a small and intuitive set of parameters in the design of the DSC predictor [<xref ref-type="bibr" rid="B6">6</xref>]. DSC is largely based on the classic GOR technique [<xref ref-type="bibr" rid="B7">7</xref>], which tabulates (during training) the frequency with which each residue appears at a given offset (-8 to +8) from a given structure element (helix, strand, coil). During prediction, each residue is assigned the structure that is most likely given the recorded frequencies for the surrounding residues. King and Sternberg augment the GOR algorithm with several parameters, including the distance to the end of the chain and local patterns of hydrophobicity. They use linear discrimination to derive a statistically favorable weighting of the parameters, resulting in a simple linear cost function; they also perform homologous sequence alignment and minor smoothing and filtering. Using about 1,000 parameters, they estimate an accuracy of <italic>Q</italic><sub><italic>&#x003b1; </italic></sub>= 73.5% for DSC. The primary difference between our predictor and DSC is that we achieve comparable accuracy (our <italic>Q</italic><sub><italic>&#x003b1; </italic></sub>= 77.6%) without providing alignment information. Incorporating an alignment profile is often responsible for 5&#x02013;7% improvement in accuracy [<xref ref-type="bibr" rid="B8">8</xref>-<xref ref-type="bibr" rid="B10">10</xref>]. In addition, we learn the position-specific residue affinities rather than using the GOR frequency count. We also consider multiple predictions simultaneously and maintain a global context rather than predicting each residue independently.</p><p>Many researchers have developed Hidden Markov Models (HMMs) for secondary structure prediction. Once it has been trained, our predictor could be converted to an HMM without losing any predictive power, as our dynamic programming procedure parallels the Viterbi algorithm for reconstructing the most likely hidden states. However, for the training phase, our system represents a soft-margin Hidden Markov SVM [<xref ref-type="bibr" rid="B11">11</xref>] rather than a traditional HMM. Unlike an HMM, a Hidden Markov SVM has a discriminative learning procedure based on a maximum margin criterion and can incorporate "overlapping features", driving the learning based on the overall predicted structure rather than via local propagation.</p><p>Tsochantaridis, Altun and Hofmann apply an integrated HMM and SVM framework for secondary structure prediction [<xref ref-type="bibr" rid="B12">12</xref>]. The technique may be similar to ours, as we are using their SVM implementation; unfortunately, there are few details published. Nguyen and Rajapakse also present a hybrid scheme in which the output of a Bayesian predictor is further refined by an SVM classifier [<xref ref-type="bibr" rid="B13">13</xref>]. The <italic>Q</italic><sub><italic>&#x003b1; </italic></sub>score is 74.1% for the Bayesian predictor alone and 77.0% for the Bayesian/SVM hybrid; the <italic>SOV</italic><sub><italic>&#x003b1; </italic></sub>score is 73.2% for the Bayesian predictor and a comparable 73.0% for the Bayesian/SVM hybrid. To the best of our knowledge, these are the highest <italic>Q</italic><sub><italic>&#x003b1; </italic></sub>and SOV<sub><italic>&#x003b1; </italic></sub>scores to date (as tested on Rost and Sander's data set [<xref ref-type="bibr" rid="B9">9</xref>]) for a method that does not utilize alignment information.</p><p>Bystroff, Thorsson, and Baker design an HMM to recognize specific structural motifs and assemble them into protein secondary structure predictions [<xref ref-type="bibr" rid="B14">14</xref>]. Using alignment profiles, they report an overall <italic>Q</italic><sub>3 </sub>value of 74.3%. Our approach may use fewer parameters, as they manually encode each target motif into a separate set of states. Martin, Gibrat, and Rodolphe develop a 21-state HMM model with 471 parameters that achieves an overall <italic>Q</italic><sub>3 </sub>value of 65.3% (without alignment profiles) and 72% (with alignment profiles) [<xref ref-type="bibr" rid="B15">15</xref>]. Alpha helices are identified based on an amphiphilic motif: a succession of two polar residues and two non-polar residues. Won, Hamelryck, Pr&#x000fc;gel-Bennet and Krogh give a genetic algorithm that automatically evolves an HMM for secondary structure prediction [<xref ref-type="bibr" rid="B16">16</xref>,<xref ref-type="bibr" rid="B17">17</xref>]. Using alignment profiles, they report an overall <italic>Q</italic><sub>3 </sub>value of 75% (only 69.4% for helices). They claim that the resulting 41-state HMM is better than any previous hand-designed HMM. While they restrict their HMM building blocks to "biologically meaningful primitives", it is unclear if there is a natural energetic interpretation of the final HMM.</p><p>Schmidler, Liu, and Brutlag develop a segmental semi-Markov Model (a generalization of the HMM), allowing each hidden state to produce a variable-length sequence of the observations [<xref ref-type="bibr" rid="B18">18</xref>,<xref ref-type="bibr" rid="B19">19</xref>]. They report a <italic>Q</italic><sub>3 </sub>value of 68.8% without using alignment profiles. Chu and Ghahramani push further in the same direction, merging with the structure of a neural network and demonstrating modest (~1%) improvements over Schmidler et al. [<xref ref-type="bibr" rid="B20">20</xref>].</p><p>While our technique is currently limited to an alpha helix predictor, for this task it performs better (<italic>Q</italic><sub><italic>&#x003b1; </italic></sub>= 77.6%) than any of the HMM-based methods described above; furthermore, it does so without any alignment information. Our technique is fundamentally different in its use of Hidden Markov SVMs for the learning stage. Lastly, some groups have applied HMM-based predictors to the specific case of transmembrane proteins, where much higher accuracy can be obtained at the expense of generality [<xref ref-type="bibr" rid="B21">21</xref>].</p><p>There has been a rich and highly successful body of work applying neural networks to secondary structure prediction. The efforts date back to Quian and Sejnowski, who design a simple feed-forward network for the problem [<xref ref-type="bibr" rid="B22">22</xref>]. Rost and Sander pioneered the automatic use of multiple sequence alignments to improve the accuracy as part of their PHD predictor [<xref ref-type="bibr" rid="B9">9</xref>], which was the top performer at CASP2. More recently, Jones employed the PSI-BLAST tool to efficiently perform the alignments, boosting his PSIPred predictor [<xref ref-type="bibr" rid="B4">4</xref>] to the top of CASP3. Baldi and colleagues employ bidirectional recurrent networks in SSPro [<xref ref-type="bibr" rid="B23">23</xref>], a system that provided the foundation for Pollastri and McLysaght's Porter server [<xref ref-type="bibr" rid="B24">24</xref>].</p><p>Petersen describes a ballotting system containing as many as 800 neural networks; while an ensemble of predictors is commonly used to gather more information, this effort is distinguished by its size [<xref ref-type="bibr" rid="B25">25</xref>]. A neural network has been followed by an HMM, resulting in a simple and fast system [<xref ref-type="bibr" rid="B26">26</xref>]; neural networks have also been used as a post-processing step for GOR predictors [<xref ref-type="bibr" rid="B27">27</xref>].</p><p>The PSIPred predictor [<xref ref-type="bibr" rid="B4">4</xref>] is among the highest scoring neural network techniques. While it achieves an overall <italic>Q</italic><sub>3 </sub>of about 77% and an SOV of 74%, its performance for alpha helices is even higher: for recent targets on EVA, an open and automatic testing platform [<xref ref-type="bibr" rid="B28">28</xref>], PSIPred offers an SOV<sub><italic>&#x003b1; </italic></sub>of 78.6% (EVA does not publish a <italic>Q</italic><sub><italic>&#x003b1; </italic></sub>value comparable to ours).</p><p>Though state-of-the-art neural network predictors such as PSIPred currently out-perform our method by about 5%, they incorporate multiple sequence alignments and are often impervious to analysis and understanding. In particular, the number of parameters in a neural network can be an order of magnitude higher than that of an HMM-based approach (see Table <xref ref-type="table" rid="T1">1</xref>). A notable exception is the network of Riis and Krogh, which is structured by hand to reduce the parameter count to as low as 311 (prediction accuracy is reported at <italic>Q</italic><sub>3 </sub>= 71.3% with alignment profiles, a good number for its time).</p><p>Recently, Support Vector Machines (SVMs) have also been used as a standalone tool for secondary structure prediction [<xref ref-type="bibr" rid="B29">29</xref>-<xref ref-type="bibr" rid="B34">34</xref>]. In contrast to our technique, which uses an SVM only for learning the parameters of an HMM, these methods apply an SVM directly to a window of residues and classify the central residue into a given secondary structure class. The number of parameters in these techniques depends on the number of support vectors; in one instance, the support vectors occupy 680 MB of memory [<xref ref-type="bibr" rid="B30">30</xref>]. Regardless of the number of parameters, it can be difficult to obtain a biological intuition for an SVM, given the non-linear kernel functions and numerous support vectors. Nonetheless, these techniques appear to have significant promise, as Nguyen and Rajapakse report an overall <italic>Q</italic><sub>3 </sub>of 79.5% and an SOV of 76.3% on the PSIPred database [<xref ref-type="bibr" rid="B29">29</xref>].</p></sec></sec><sec><title>Results and discussion</title><p>We have applied our method to the problem of all-alpha protein secondary structure prediction. We worked with a set of 300 non-homologous all-alpha proteins taken from EVA's largest sequence-unique subset [<xref ref-type="bibr" rid="B35">35</xref>] of the PDB at the end of July 2005. The sequences and structures have been extracted from PDB data processed by DSSP [<xref ref-type="bibr" rid="B36">36</xref>]. Only alpha helices have been considered (H residues in DSSP files); everything else has been lumped as <italic>coil </italic>regions.</p><p>In our experiments, we split our 300 proteins into two 150 protein subsets. The first set is used to train our parameterizable cost function; the second set is used to evaluate the cost function once its parameters have been learned. Since the results vary a bit depending on how the proteins are split in two sets, we train the cost function on 20 random partitions into training and test sets, and report the average performance. Our predictor minimizes the free-energy function <italic>G </italic>using the Viterbi algorithm on a simple 7-state Finite State Machine (shown in Figure <xref ref-type="fig" rid="F1">1</xref>). The Finite State Machine recognizes alpha helices of length greater than 3 amino acids using 302 elementary free-energies as learned weights. These weigh each amino acid's propensity to be within a helix (20 energies), or within three residues of an N- or C-cap of a helix (20 &#x000d7; 7 &#x000d7; 2 energies). Two weights also penalize 1 and 2 length coils. The motivation for and implementation of the Finite State Machine is described in more detail later.</p><p>Table <xref ref-type="table" rid="T2">2</xref> presents our total results using both the Q<sub><italic>&#x003b1; </italic></sub>and SOV<sub><italic>&#x003b1; </italic></sub>metrics. Figures <xref ref-type="fig" rid="F2">2</xref> and <xref ref-type="fig" rid="F3">3</xref> show histograms detailing the distribution of each score. The Q<sub><italic>&#x003b1; </italic></sub>metric is simply the number of correctly predicted residues divided by sequence length. SOV<sub><italic>&#x003b1; </italic></sub>is a more elaborate metric that has been designed to ignore small errors in helix-coil transition position, but heavily penalize more fundamental errors such as gaps appearing in a helix [<xref ref-type="bibr" rid="B3">3</xref>].</p><p>On average, our method predicts helices in all-alpha proteins with an accuracy of 77.6% (Q<sub><italic>&#x003b1;</italic></sub>) or 73.4% (SOV<sub><italic>&#x003b1;</italic></sub>). Unfortunately, these results are difficult to compare with existing prediction methods which usually do predictions on both alpha helices and beta strands. Rost and Sanders caution that restricting the test set to all-alpha proteins can result in up to a 3% gain in accuracy [<xref ref-type="bibr" rid="B9">9</xref>]. Nonetheless, if one does compare our technique with the previous best amongst methods that do not utilize alignment information [<xref ref-type="bibr" rid="B5">5</xref>], our results represent a 3.5% improvement in Q<sub><italic>&#x003b1; </italic></sub>and a 0.2% improvement in SOV<sub><italic>&#x003b1;</italic></sub>.</p><p>Additional care should be taken in comparing these numbers to recent techniques such as PSIPred [<xref ref-type="bibr" rid="B4">4</xref>], which consider 3<sub>10 </sub>helices (the DSSP state 'G') to be part of a helix rather than a loop; they report gains of about 2% in overall <italic>Q</italic><sub>3 </sub>if helices are restricted to 4-helices (as in most HMM techniques, including ours). Apart from prediction accuracy, our technique is distinguished from others by its emphasis on an intuitive and biophysically-motivated cost function. While some of techniques require upwards of 10,000 parameters (see Table <xref ref-type="table" rid="T1">1</xref>), our predictor achieves competitive accuracy using only 302 parameters.</p><p>The real power of the machine learning method we use is its applicability beyond HMM models. As will become evident in the description of the method, we could describe protein structures as a parse tree of a context-free grammar (or multi-tape grammar) rather than as a sequence of HMM states. With these enriched descriptions, we should be able to include in the cost function interactions between adjacent strands of a beta sheet. This should allow us to incorporate beta sheet prediction into our algorithm.</p><p>Unlike most secondary structure methods, we would then be able to predict not only which residues participate in a beta sheet, but also which residues are forming hydrogen bonds between adjacent sheets.</p></sec><sec><title>Conclusion</title><p>This work is a promising first pass at using SVM techniques to find the elementary free-energies needed to predict protein secondary structure. The method we use is general and can be extended beyond the all-alpha case described here. In future work, we plan to extend this method to super-secondary structure prediction, generating contact maps of individual hydrogen bonds in beta sheets.</p></sec><sec sec-type="methods"><title>Methods</title><p>It is widely believed that when a protein is folded, its free-energy approaches a thermodynamic minimum. We therefore treat structure prediction as an optimization problem.</p><sec><title>Formal optimization problem</title><p>In our technique, we define a free-energy function <italic>G</italic>(<bold>x</bold>, <bold>y</bold>) that estimates the free-energy of an amino acid sequence <bold>x </bold>when folded into a candidate secondary structure <bold>y</bold>. Our predictor outputs the secondary structure <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M1" name="1471-2105-8-S5-S3-i1" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mover accent="true"><mml:mi>y</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaaieqacuWF5bqEgaqcaaaa@2E3D@</mml:annotation></mml:semantics></mml:math></inline-formula> that has the minimal free-energy according to <italic>G</italic>:</p><p><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M2" name="1471-2105-8-S5-S3-i2" overflow="scroll">
                  <mml:semantics definitionURL="" encoding="">
                     <mml:mrow>
                        <mml:mover accent="true">
                           <mml:mi mathvariant="bold">y</mml:mi>
                           <mml:mo mathvariant="bold">^</mml:mo>
                        </mml:mover>
                        <mml:mo>=</mml:mo>
                        <mml:munder>
                           <mml:mrow>
                              <mml:mi>arg</mml:mi>
                              <mml:mo>&#x02061;</mml:mo>
                              <mml:mi>min</mml:mi>
                              <mml:mo>&#x02061;</mml:mo>
                           </mml:mrow>
                           <mml:mrow>
                              <mml:mi mathvariant="bold">y</mml:mi>
                              <mml:mo>&#x02208;</mml:mo>
                              <mml:mi mathvariant="script">Y</mml:mi>
                           </mml:mrow>
                        </mml:munder>
                        <mml:mi>G</mml:mi>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mi mathvariant="bold">x</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:mi mathvariant="bold">y</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo>.</mml:mo>
                        <mml:mtext>&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;</mml:mtext>
                        <mml:mrow>
                           <mml:mo>(</mml:mo>
                           <mml:mn>1</mml:mn>
                           <mml:mo>)</mml:mo>
                        </mml:mrow>
                     </mml:mrow>
                     <mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaaieqacuWF5bqEgaqcaiabg2da9maaxababaGagiyyaeMaeiOCaiNaei4zaCMagiyBa0MaeiyAaKMaeiOBa4galeaacqWF5bqEcqGHiiIZt0uy0HwzTfgDPnwy1egaryqtHrhAL1wy0L2yHvdaiqaacqGFyeFwaeqaaOGaem4raCKaeiikaGIae8hEaGNaeiilaWIae8xEaKNaeiykaKIaeiOla4IaaCzcaiaaxMaadaqadaqaaiabigdaXaGaayjkaiaawMcaaaaa@518A@</mml:annotation>
                  </mml:semantics>
               </mml:math></inline-formula></p><p>To go from this general statement to a working algorithm, we need to a find free-energy function <italic>G </italic>and a set of structures <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M3" name="1471-2105-8-S5-S3-i3" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">Y</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaat0uy0HwzTfgDPnwy1egaryqtHrhAL1wy0L2yHvdaiqaacqWFyeFwaaa@3850@</mml:annotation></mml:semantics></mml:math></inline-formula> for which the minimization shown in equation (1) is easy to compute. In choosing <italic>G </italic>and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M4" name="1471-2105-8-S5-S3-i3" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">Y</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaat0uy0HwzTfgDPnwy1egaryqtHrhAL1wy0L2yHvdaiqaacqWFyeFwaaa@3850@</mml:annotation></mml:semantics></mml:math></inline-formula>, we tradeoff the ability to efficiently minimize <italic>G </italic>with the ability to accurately capture the richness and detailed physics of protein structure. Atomistic models are able to capture the whole range of structures, and incorporate all the physical interactions between atoms. However, because of this detail they can only be optimized using heuristic methods. We therefore prefer to consider a simplified set of structures <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M5" name="1471-2105-8-S5-S3-i3" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">Y</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaat0uy0HwzTfgDPnwy1egaryqtHrhAL1wy0L2yHvdaiqaacqWFyeFwaaa@3850@</mml:annotation></mml:semantics></mml:math></inline-formula>, and a cost function <italic>G </italic>with lumped parameters that try to approach physical reality.</p><p>These lumped parameters are difficult to determine experimentally. We will therefore define a class <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M6" name="1471-2105-8-S5-S3-i4" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">G</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaat0uy0HwzTfgDPnwy1egaryqtHrhAL1wy0L2yHvdaiqaacqWFge=raaa@382C@</mml:annotation></mml:semantics></mml:math></inline-formula> of candidate free-energy functions that are easy to optimize over some set of structures <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M7" name="1471-2105-8-S5-S3-i3" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">Y</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaat0uy0HwzTfgDPnwy1egaryqtHrhAL1wy0L2yHvdaiqaacqWFyeFwaaa@3850@</mml:annotation></mml:semantics></mml:math></inline-formula>. Then we will use machine learning techniques to pick a good <italic>G </italic>from all the candidates in <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M8" name="1471-2105-8-S5-S3-i4" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">G</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaat0uy0HwzTfgDPnwy1egaryqtHrhAL1wy0L2yHvdaiqaacqWFge=raaa@382C@</mml:annotation></mml:semantics></mml:math></inline-formula>. The machine learning will use structure information from the Protein Data Bank (PDB) [<xref ref-type="bibr" rid="B37">37</xref>] to determine which <italic>G </italic>to pick. Given a set of training examples {(<bold>x</bold><sub><italic>i</italic></sub>, <bold>y</bold><sub><italic>i</italic></sub>): <italic>i </italic>= 1,...,<italic>k</italic>}, the learning algorithm needs to find a <italic>G </italic>&#x02208; <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M9" name="1471-2105-8-S5-S3-i4" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">G</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaat0uy0HwzTfgDPnwy1egaryqtHrhAL1wy0L2yHvdaiqaacqWFge=raaa@382C@</mml:annotation></mml:semantics></mml:math></inline-formula> such that:</p><p><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M10" name="1471-2105-8-S5-S3-i5" overflow="scroll">
                  <mml:semantics definitionURL="" encoding="">
                     <mml:mrow>
                        <mml:mo>&#x02200;</mml:mo>
                        <mml:mi>i</mml:mi>
                        <mml:mo>:</mml:mo>
                        <mml:msub>
                           <mml:mi mathvariant="bold">y</mml:mi>
                           <mml:mi mathvariant="bold">i</mml:mi>
                        </mml:msub>
                        <mml:mo>=</mml:mo>
                        <mml:munder>
                           <mml:mrow>
                              <mml:mi>arg</mml:mi>
                              <mml:mo>&#x02061;</mml:mo>
                              <mml:mi>min</mml:mi>
                              <mml:mo>&#x02061;</mml:mo>
                           </mml:mrow>
                           <mml:mrow>
                              <mml:mi mathvariant="bold">y</mml:mi>
                              <mml:mo>&#x02208;</mml:mo>
                              <mml:mi mathvariant="script">Y</mml:mi>
                           </mml:mrow>
                        </mml:munder>
                        <mml:mi>G</mml:mi>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:msub>
                           <mml:mi mathvariant="bold">x</mml:mi>
                           <mml:mi>i</mml:mi>
                        </mml:msub>
                        <mml:mo>,</mml:mo>
                        <mml:mi mathvariant="bold">y</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo>.</mml:mo>
                        <mml:mtext>&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;</mml:mtext>
                        <mml:mrow>
                           <mml:mo>(</mml:mo>
                           <mml:mn>2</mml:mn>
                           <mml:mo>)</mml:mo>
                        </mml:mrow>
                     </mml:mrow>
                     <mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaacqGHaiIicqWGPbqAcqGG6aGoieqacqWF5bqEdaWgaaWcbaGaemyAaKgabeaakiabg2da9maaxababaGagiyyaeMaeiOCaiNaei4zaCMagiyBa0MaeiyAaKMaeiOBa4galeaacqWF5bqEcqGHiiIZt0uy0HwzTfgDPnwy1egaryqtHrhAL1wy0L2yHvdaiqaacqGFyeFwaeqaaOGaem4raCKaeiikaGIae8hEaG3aaSbaaSqaaiabdMgaPbqabaGccqGGSaalcqWF5bqEcqGGPaqkcqGGUaGlcaWLjaGaaCzcamaabmaabaGaeGOmaidacaGLOaGaayzkaaaaaa@57C5@</mml:annotation>
                  </mml:semantics>
               </mml:math></inline-formula></p><p>In practice, this <italic>G </italic>may not exist or may not be unique, so the machine learning algorithm may have to pick a good approximation, or select a <italic>G </italic>that is more likely to generalize well to proteins not in the training set. We will now look more closely at how a good <italic>G </italic>is selected and later we will be more specific about what <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M11" name="1471-2105-8-S5-S3-i4" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">G</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaat0uy0HwzTfgDPnwy1egaryqtHrhAL1wy0L2yHvdaiqaacqWFge=raaa@382C@</mml:annotation></mml:semantics></mml:math></inline-formula> and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M12" name="1471-2105-8-S5-S3-i3" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">Y</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaat0uy0HwzTfgDPnwy1egaryqtHrhAL1wy0L2yHvdaiqaacqWFyeFwaaa@3850@</mml:annotation></mml:semantics></mml:math></inline-formula> are.</p></sec><sec><title>Iterative constraint based approach</title><p>First, we notice that equation (2) can be rewritten as the problem of finding a function <italic>G </italic>that satisfies the large set of inequality constraints</p><p>&#x02200;<italic>i</italic>, &#x02200;<italic>y </italic>&#x02208; <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M13" name="1471-2105-8-S5-S3-i3" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">Y</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaat0uy0HwzTfgDPnwy1egaryqtHrhAL1wy0L2yHvdaiqaacqWFyeFwaaa@3850@</mml:annotation></mml:semantics></mml:math></inline-formula>\{<bold>y</bold><sub><italic>i</italic></sub>}: <italic>G</italic>(<bold>x</bold><sub><italic>i</italic></sub>, <bold>y</bold><sub><italic>i</italic></sub>) &#x0003c;<italic>G</italic>(<bold>x</bold><sub><italic>i</italic></sub>, <bold>y</bold>). &#x000a0;&#x000a0;&#x000a0; (3)</p><p>Unfortunately, the set of all secondary structures <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M14" name="1471-2105-8-S5-S3-i3" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">Y</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaat0uy0HwzTfgDPnwy1egaryqtHrhAL1wy0L2yHvdaiqaacqWFyeFwaaa@3850@</mml:annotation></mml:semantics></mml:math></inline-formula> is exponentially large, so finding a <italic>G </italic>&#x02208; <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M15" name="1471-2105-8-S5-S3-i4" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">G</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaat0uy0HwzTfgDPnwy1egaryqtHrhAL1wy0L2yHvdaiqaacqWFge=raaa@382C@</mml:annotation></mml:semantics></mml:math></inline-formula> that satisfies all these inequalities directly is computationally intractable. Our approach reduces the problem by ignoring as many constraints as possible, only considering the constraints it is "forced" to consider.</p><p>In our method, the reduced problem is defined as the problem of finding a function <italic>G' </italic>that satisfies the set of constraints</p><p>&#x02200;<italic>i</italic>, &#x02200;<italic>y </italic>&#x02208; <italic>S</italic><sub><italic>i</italic></sub>: <italic>G'</italic>(<bold>x</bold><sub><italic>i</italic></sub>, <bold>y</bold><sub><italic>i</italic></sub>) &#x0003c;<italic>G'</italic>(<bold>x</bold><sub><italic>i</italic></sub>, <bold>y</bold>), &#x000a0;&#x000a0;&#x000a0; (4)</p><p>for some <italic>S</italic><sub><italic>i </italic></sub>&#x02286; <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M16" name="1471-2105-8-S5-S3-i3" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">Y</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaat0uy0HwzTfgDPnwy1egaryqtHrhAL1wy0L2yHvdaiqaacqWFyeFwaaa@3850@</mml:annotation></mml:semantics></mml:math></inline-formula>\{<bold>y</bold><sub><italic>i</italic></sub>}.</p><p>Initially, we begin with no constraints at all (that is, <italic>S</italic><sub><italic>i </italic></sub>= &#x02205; for all <italic>i</italic>) and we choose some function <italic>G</italic>' &#x02208; <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M17" name="1471-2105-8-S5-S3-i4" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">G</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaat0uy0HwzTfgDPnwy1egaryqtHrhAL1wy0L2yHvdaiqaacqWFge=raaa@382C@</mml:annotation></mml:semantics></mml:math></inline-formula>. Note that, since we start with no constraints, any function <italic>G</italic>' &#x02208; <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M18" name="1471-2105-8-S5-S3-i4" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">G</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaat0uy0HwzTfgDPnwy1egaryqtHrhAL1wy0L2yHvdaiqaacqWFge=raaa@382C@</mml:annotation></mml:semantics></mml:math></inline-formula> initially satisfies equation (4). We then need to check whether <italic>G' </italic>approximates the solution <italic>G </italic>to the set of constraints (2). In particular, we verify whether <italic>G' </italic>can be used to approximate <bold>y</bold><sub>1 </sub>as the solution <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M19" name="1471-2105-8-S5-S3-i1" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mover accent="true"><mml:mi>y</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaaieqacuWF5bqEgaqcaaaa@2E3D@</mml:annotation></mml:semantics></mml:math></inline-formula><sub>1 </sub>of the problem</p><p><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M20" name="1471-2105-8-S5-S3-i6" overflow="scroll">
                  <mml:semantics definitionURL="" encoding="">
                     <mml:mrow>
                        <mml:msub>
                           <mml:mover accent="true">
                              <mml:mi mathvariant="bold">y</mml:mi>
                              <mml:mo mathvariant="bold">^</mml:mo>
                           </mml:mover>
                           <mml:mn>1</mml:mn>
                        </mml:msub>
                        <mml:mo>=</mml:mo>
                        <mml:munder>
                           <mml:mrow>
                              <mml:mi>arg</mml:mi>
                              <mml:mo>&#x02061;</mml:mo>
                              <mml:mi>min</mml:mi>
                              <mml:mo>&#x02061;</mml:mo>
                           </mml:mrow>
                           <mml:mrow>
                              <mml:mi mathvariant="bold">y</mml:mi>
                              <mml:mo>&#x02208;</mml:mo>
                              <mml:mi mathvariant="script">Y</mml:mi>
                           </mml:mrow>
                        </mml:munder>
                        <mml:msup>
                           <mml:mi>G</mml:mi>
                           <mml:mo>&#x02032;</mml:mo>
                        </mml:msup>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:msub>
                           <mml:mi mathvariant="bold">x</mml:mi>
                           <mml:mn>1</mml:mn>
                        </mml:msub>
                        <mml:mo>,</mml:mo>
                        <mml:mi mathvariant="bold">y</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo>.</mml:mo>
                     </mml:mrow>
                     <mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaaieqacuWF5bqEgaqcamaaBaaaleaacqaIXaqmaeqaaOGaeyypa0ZaaCbeaeaacyGGHbqycqGGYbGCcqGGNbWzcyGGTbqBcqGGPbqAcqGGUbGBaSqaaiab=Lha5jabgIGioprtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaGabaiab+Hr8zbqabaGccuWGhbWrgaqbaiabcIcaOiab=Hha4naaBaaaleaacqaIXaqmaeqaaOGaeiilaWIae8xEaKNaeiykaKIaeiOla4caaa@5025@</mml:annotation>
                  </mml:semantics>
               </mml:math></inline-formula></p><p>If <italic>G'</italic>(<bold>x</bold><sub>1</sub>, <bold>y</bold><sub>1</sub>) &#x0003c;<italic>G'</italic>(<bold>x</bold><sub>1</sub>, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M21" name="1471-2105-8-S5-S3-i1" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mover accent="true"><mml:mi mathvariant="bold">y</mml:mi><mml:mo mathvariant="bold">^</mml:mo></mml:mover><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaaieqacuWF5bqEgaqcaaaa@2E3D@</mml:annotation></mml:semantics></mml:math></inline-formula><sub>1</sub>) + <italic>&#x003b5;</italic>, we say that <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M22" name="1471-2105-8-S5-S3-i1" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mover accent="true"><mml:mi mathvariant="bold">y</mml:mi><mml:mo mathvariant="bold">^</mml:mo></mml:mover><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaaieqacuWF5bqEgaqcaaaa@2E3D@</mml:annotation></mml:semantics></mml:math></inline-formula><sub>1 </sub>is "close" to <bold>y</bold><sub>1 </sub>in the sense that <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M23" name="1471-2105-8-S5-S3-i1" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mover accent="true"><mml:mi mathvariant="bold">y</mml:mi><mml:mo mathvariant="bold">^</mml:mo></mml:mover><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaaieqacuWF5bqEgaqcaaaa@2E3D@</mml:annotation></mml:semantics></mml:math></inline-formula><sub>1 </sub>is a close enough approximation of <bold>y</bold><sub>1</sub>. If <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M24" name="1471-2105-8-S5-S3-i1" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mover accent="true"><mml:mi>y</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaaieqacuWF5bqEgaqcaaaa@2E3D@</mml:annotation></mml:semantics></mml:math></inline-formula><sub>1 </sub>is close to <bold>y</bold><sub>1</sub>, we go on to the next optimization problem</p><p><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M25" name="1471-2105-8-S5-S3-i7" overflow="scroll">
                  <mml:semantics definitionURL="" encoding="">
                     <mml:mrow>
                        <mml:msub>
                           <mml:mover accent="true">
                              <mml:mi mathvariant="bold">y</mml:mi>
                              <mml:mo mathvariant="bold">^</mml:mo>
                           </mml:mover>
                           <mml:mn>2</mml:mn>
                        </mml:msub>
                        <mml:mo>=</mml:mo>
                        <mml:munder>
                           <mml:mrow>
                              <mml:mi>arg</mml:mi>
                              <mml:mo>&#x02061;</mml:mo>
                              <mml:mi>min</mml:mi>
                              <mml:mo>&#x02061;</mml:mo>
                           </mml:mrow>
                           <mml:mrow>
                              <mml:mi mathvariant="bold">y</mml:mi>
                              <mml:mo>&#x02208;</mml:mo>
                              <mml:mi mathvariant="script">Y</mml:mi>
                           </mml:mrow>
                        </mml:munder>
                        <mml:msup>
                           <mml:mi>G</mml:mi>
                           <mml:mo>&#x02032;</mml:mo>
                        </mml:msup>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:msub>
                           <mml:mi mathvariant="bold">x</mml:mi>
                           <mml:mn mathvariant="bold">2</mml:mn>
                        </mml:msub>
                        <mml:mo>,</mml:mo>
                        <mml:mi mathvariant="bold">y</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo>.</mml:mo>
                     </mml:mrow>
                     <mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaaieqacuWF5bqEgaqcamaaBaaaleaacqaIYaGmaeqaaOGaeyypa0ZaaCbeaeaacyGGHbqycqGGYbGCcqGGNbWzcyGGTbqBcqGGPbqAcqGGUbGBaSqaaiab=Lha5jabgIGioprtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaGabaiab+Hr8zbqabaGccuWGhbWrgaqbaiabcIcaOiab=Hha4naaBaaaleaacqaIYaGmaeqaaOGaeiilaWIae8xEaKNaeiykaKIaeiOla4caaa@5029@</mml:annotation>
                  </mml:semantics>
               </mml:math></inline-formula></p><p>If <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M26" name="1471-2105-8-S5-S3-i1" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mover accent="true"><mml:mi mathvariant="bold">y</mml:mi><mml:mo mathvariant="bold">^</mml:mo></mml:mover><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaaieqacuWF5bqEgaqcaaaa@2E3D@</mml:annotation></mml:semantics></mml:math></inline-formula><sub>1 </sub>is not close to <bold>y</bold><sub>1</sub>, this means the constraint <italic>G'</italic>(<bold>x</bold><sub>1</sub>, <bold>y</bold><sub>1</sub>) &#x0003c;<italic>G'</italic>(<bold>x</bold><sub>1</sub>, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M27" name="1471-2105-8-S5-S3-i1" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mover accent="true"><mml:mi mathvariant="bold">y</mml:mi><mml:mo mathvariant="bold">^</mml:mo></mml:mover><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaaieqacuWF5bqEgaqcaaaa@2E3D@</mml:annotation></mml:semantics></mml:math></inline-formula><sub>1</sub>) in equation (3) has been violated.</p><p>Therefore we must add this constraint to our reduced problem, replacing <italic>S</italic><sub>1 </sub>by <italic>S</italic><sub>1 </sub>&#x0222a; {<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M28" name="1471-2105-8-S5-S3-i1" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mover accent="true"><mml:mi mathvariant="bold">y</mml:mi><mml:mo mathvariant="bold">^</mml:mo></mml:mover><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaaieqacuWF5bqEgaqcaaaa@2E3D@</mml:annotation></mml:semantics></mml:math></inline-formula><sub>1</sub>}. In order to solve the new reduced problem we need to find a new <italic>G' </italic>that satisfies the old and new constraints. At all times the number of constraints in the reduced problem is relatively small such that it is computationally feasible to find its solution.</p><p>Whenever a prediction <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M29" name="1471-2105-8-S5-S3-i1" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mover accent="true"><mml:mi mathvariant="bold">y</mml:mi><mml:mo mathvariant="bold">^</mml:mo></mml:mover><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaaieqacuWF5bqEgaqcaaaa@2E3D@</mml:annotation></mml:semantics></mml:math></inline-formula><sub><italic>i </italic></sub>is not satisfactorily close to <bold>y</bold><sub><italic>i</italic></sub>, we add more constraints. For instance, Figure <xref ref-type="fig" rid="F4">4</xref> shows our problem reduction for the training example (<bold>x</bold><sub>1</sub>, <bold>y</bold><sub>1</sub>). Note that the reduced problems lead to the constraints <italic>G'</italic>(<bold>x</bold><sub>1</sub>, <bold>y</bold><sub>1</sub>) &#x0003c;<italic>G'</italic>(<bold>x</bold><sub>1</sub>, <bold>y</bold><sup>1</sup>), <italic>G'</italic>(<bold>x</bold><sub>1</sub>, <bold>y</bold><sub>1</sub>) &#x0003c;<italic>G'</italic>(<bold>x</bold><sub>1</sub>, <bold>y</bold><sup>7</sup>), <italic>G'</italic>(<bold>x</bold><sub>1</sub>, <bold>y</bold><sub>1</sub>) &#x0003c;<italic>G'</italic>(<bold>x</bold><sub>1</sub>, <bold>y</bold><sup>245</sup>), etc., where <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M30" name="1471-2105-8-S5-S3-i3" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">Y</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaat0uy0HwzTfgDPnwy1egaryqtHrhAL1wy0L2yHvdaiqaacqWFyeFwaaa@3850@</mml:annotation></mml:semantics></mml:math></inline-formula> = {<bold>y</bold><sup>1</sup>, <bold>y</bold><sup>2</sup>,...,<bold>y</bold><sup><italic>m</italic></sup>} (in other words, <italic>S</italic><sub>1 </sub>= {<bold>y</bold><sup>1</sup>, <bold>y</bold><sup>7</sup>, <bold>y</bold><sup>245</sup>}).</p><p>The algorithm terminates if no constraints need to be added. That is, each prediction is a good approximation,</p><p><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M31" name="1471-2105-8-S5-S3-i8" overflow="scroll">
                  <mml:semantics definitionURL="" encoding="">
                     <mml:mrow>
                        <mml:mo>&#x02200;</mml:mo>
                        <mml:mi>i</mml:mi>
                        <mml:mo>:</mml:mo>
                        <mml:msup>
                           <mml:mi>G</mml:mi>
                           <mml:mo>&#x02032;</mml:mo>
                        </mml:msup>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:msub>
                           <mml:mi mathvariant="bold">x</mml:mi>
                           <mml:mi mathvariant="bold">i</mml:mi>
                        </mml:msub>
                        <mml:mo>,</mml:mo>
                        <mml:msub>
                           <mml:mi mathvariant="bold">y</mml:mi>
                           <mml:mi mathvariant="bold">i</mml:mi>
                        </mml:msub>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo>&#x0003c;</mml:mo>
                        <mml:msup>
                           <mml:mi>G</mml:mi>
                           <mml:mo>&#x02032;</mml:mo>
                        </mml:msup>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:msub>
                           <mml:mi mathvariant="bold">x</mml:mi>
                           <mml:mi mathvariant="bold">i</mml:mi>
                        </mml:msub>
                        <mml:mo>,</mml:mo>
                        <mml:msub>
                           <mml:mover accent="true">
                              <mml:mi mathvariant="bold">y</mml:mi>
                              <mml:mo mathvariant="bold">^</mml:mo>
                           </mml:mover>
                           <mml:mi>i</mml:mi>
                        </mml:msub>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo>+</mml:mo>
                        <mml:mi>&#x003b5;</mml:mi>
                        <mml:mi/>
                        <mml:mtext>where&#x000a0;</mml:mtext>
                        <mml:msub>
                           <mml:mover accent="true">
                              <mml:mi mathvariant="bold">y</mml:mi>
                              <mml:mo mathvariant="bold">^</mml:mo>
                           </mml:mover>
                           <mml:mi>i</mml:mi>
                        </mml:msub>
                        <mml:mo>=</mml:mo>
                        <mml:munder>
                           <mml:mrow>
                              <mml:mi>arg</mml:mi>
                              <mml:mo>&#x02061;</mml:mo>
                              <mml:mi>min</mml:mi>
                              <mml:mo>&#x02061;</mml:mo>
                           </mml:mrow>
                           <mml:mrow>
                              <mml:mi mathvariant="bold">y</mml:mi>
                              <mml:mo>&#x02208;</mml:mo>
                              <mml:mi mathvariant="script">Y</mml:mi>
                           </mml:mrow>
                        </mml:munder>
                        <mml:msup>
                           <mml:mi>G</mml:mi>
                           <mml:mo>&#x02032;</mml:mo>
                        </mml:msup>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:msub>
                           <mml:mi mathvariant="bold">x</mml:mi>
                           <mml:mi mathvariant="bold">i</mml:mi>
                        </mml:msub>
                        <mml:mo>,</mml:mo>
                        <mml:mi mathvariant="bold">y</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo>.</mml:mo>
                        <mml:mtext>&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;</mml:mtext>
                        <mml:mrow>
                           <mml:mo>(</mml:mo>
                           <mml:mn>5</mml:mn>
                           <mml:mo>)</mml:mo>
                        </mml:mrow>
                     </mml:mrow>
                     <mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaacqGHaiIicqWGPbqAcqGG6aGocuWGhbWrgaqbaiabcIcaOGqabiab=Hha4naaBaaaleaacqWGPbqAaeqaaOGaeiilaWIae8xEaK3aaSbaaSqaaiabdMgaPbqabaGccqGGPaqkcqGH8aapcuWGhbWrgaqbaiabcIcaOiab=Hha4naaBaaaleaacqWGPbqAaeqaaOGaeiilaWIaf8xEaKNbaKaadaWgaaWcbaGaemyAaKgabeaakiabcMcaPiabgUcaRGGaciab+v7aLjab+bcaGiabbEha3jabbIgaOjabbwgaLjabbkhaYjabbwgaLjabbccaGiqb=Lha5zaajaWaaSbaaSqaaiabdMgaPbqabaGccqGH9aqpdaWfqaqaaiGbcggaHjabckhaYjabcEgaNjGbc2gaTjabcMgaPjabc6gaUbWcbaGae8xEaKNaeyicI48enfgDOvwBHrxAJfwnHbqeg0uy0HwzTfgDPnwy1aaceaGae0hgXNfabeaakiqbdEeahzaafaGaeiikaGIae8hEaG3aaSbaaSqaaiabdMgaPbqabaGccqGGSaalcqWF5bqEcqGGPaqkcqGGUaGlcaWLjaGaaCzcamaabmaabaGaeGynaudacaGLOaGaayzkaaaaaa@7773@</mml:annotation>
                  </mml:semantics>
               </mml:math></inline-formula></p><p>This is equivalent to</p><p>&#x02200;<italic>i</italic>, &#x02200;<italic>y </italic>&#x02208; <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M32" name="1471-2105-8-S5-S3-i3" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">Y</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaat0uy0HwzTfgDPnwy1egaryqtHrhAL1wy0L2yHvdaiqaacqWFyeFwaaa@3850@</mml:annotation></mml:semantics></mml:math></inline-formula>\{<bold>y</bold><sub><italic>i</italic></sub>}:<italic>G'</italic>(<bold>x</bold><sub><italic>i</italic></sub>, <bold>y</bold><sub><italic>i</italic></sub>) &#x0003c;<italic>G'</italic>(<bold>x</bold><sub><italic>i</italic></sub>, <bold>y</bold>) + <italic>&#x003b5;</italic>. &#x000a0;&#x000a0;&#x000a0; (6)</p><p>This is similar to the full set of constraints on <italic>G </italic>in equation (3), except that <italic>G' </italic>need only satisfy each inequality within a distance of <italic>&#x003b5;</italic>.</p></sec><sec><title>Linear cost function</title><p>One important assumption we make is that the family of free energy functions <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M33" name="1471-2105-8-S5-S3-i4" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">G</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaat0uy0HwzTfgDPnwy1egaryqtHrhAL1wy0L2yHvdaiqaacqWFge=raaa@382C@</mml:annotation></mml:semantics></mml:math></inline-formula> is linear. That is, the total free energy of the protein is a sum of elementary interactions. This simplification agrees with many mathematical models of the energy force fields that control protein folding. For example, electrostatic, Van der Waals, stretch, bend, and torsion forces can all be described by the sum of energy terms for each pair of molecular elements. Given this, we can formally define the family of functions <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M34" name="1471-2105-8-S5-S3-i4" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">G</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaat0uy0HwzTfgDPnwy1egaryqtHrhAL1wy0L2yHvdaiqaacqWFge=raaa@382C@</mml:annotation></mml:semantics></mml:math></inline-formula> to be</p><p><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M35" name="1471-2105-8-S5-S3-i4" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">G</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaat0uy0HwzTfgDPnwy1egaryqtHrhAL1wy0L2yHvdaiqaacqWFge=raaa@382C@</mml:annotation></mml:semantics></mml:math></inline-formula> = {<italic>G</italic><sub><bold>w</bold></sub>: (<bold>x</bold>, <bold>y</bold>) &#x02192; &#x027e8;<bold>w</bold>, &#x003a8;(<bold>x</bold>, <bold>y</bold>)&#x027e9; : for some <bold>w</bold>}. &#x000a0;&#x000a0;&#x000a0; (7)</p><p>Here the feature function &#x003a8; is fixed and known, representing the specific energy characteristics that we are interested in. For example, one element of the vector &#x003a8;(<bold>x</bold>, <bold>y</bold>) might be the number of proline residues from sequence <bold>x </bold>that appear within an alpha helix in candidate structure <bold>y</bold>. Additional details on our design of &#x003a8; appears later. By definition of a linear function, the dot product of the vector <bold>w </bold>(notated by &#x027e8;, &#x027e9;) can then be taken to appropriately weight the importance of individual terms within &#x003a8;. With this assumption, the reduced problem's constraints given by equation (4) can be rewritten as</p><p>&#x02200;<italic>i</italic>, &#x02200;<italic>y </italic>&#x02208; <italic>S</italic><sub><italic>i </italic></sub>: <italic>G</italic><sub><bold>w</bold></sub>(<bold>x</bold><sub><italic>i</italic></sub>, <bold>y</bold><sub><italic>i</italic></sub>) &#x0003c;<italic>G</italic><sub><bold>w</bold></sub>(<bold>x</bold><sub><italic>i</italic></sub>, <bold>y</bold>). &#x000a0;&#x000a0;&#x000a0; (8)</p><p>In order to solve the reduced problem, we need to find the unknown weight vector <bold>w </bold>such that these constraints are satisfied. Again, since <italic>G</italic><sub><bold>w </bold></sub>is a linear function, this set of constraints can translate into</p><p>&#x02200;<italic>i</italic>, &#x02200;<bold>y </bold>&#x02208; <italic>S</italic><sub><italic>i </italic></sub>: &#x027e8;<bold>w</bold>, &#x00394;&#x003a8;<sub><italic>i</italic></sub>(<bold>y</bold>)&#x027e9; &#x0003e; 0, &#x000a0;&#x000a0;&#x000a0; (9)</p><p>where &#x00394;&#x003a8;<sub><italic>i</italic></sub>(<bold>y</bold>) = &#x003a8;(<bold>x</bold><sub><italic>i</italic></sub>, <bold>y</bold>) - &#x003a8;(<bold>x</bold><sub><italic>i</italic></sub>, <bold>y</bold><sub><italic>i</italic></sub>). This reformulation of the constraints allows this problem to be solved in a much more elegant and computationally efficient manner. We use the powerful technique of Support Vector Machines to quickly determine the function <italic>G</italic><sub><bold>w</bold></sub>, although many other techniques are possible.</p></sec><sec><title>Iteratively constraining Support Vector Machines</title><p>Support Vector Machines (SVMs) are a fast and effective tool for generating functions from a set of labeled input training data. SVMs are able to determine a set of weights <bold>w </bold>for the function <italic>G</italic><sub><bold>w </bold></sub>that will allow <italic>G</italic><sub><bold>w </bold></sub>to accurately map all of the training example inputs <bold>x</bold><sub><italic>i </italic></sub>to outputs <bold>y</bold><sub><italic>i</italic></sub>. This problem can be formulated as a quadratic program, in which the variables are the weights <bold>w </bold>and a set of "slack variables" <italic>&#x003be;</italic><sub><italic>i</italic></sub>:</p><p><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M36" name="1471-2105-8-S5-S3-i9" overflow="scroll">
                  <mml:semantics definitionURL="" encoding="">
                     <mml:mrow>
                        <mml:mover accent="true">
                           <mml:mi mathvariant="bold">w</mml:mi>
                           <mml:mo mathvariant="bold">^</mml:mo>
                        </mml:mover>
                        <mml:mo>=</mml:mo>
                        <mml:munder>
                           <mml:mrow>
                              <mml:mi>arg</mml:mi>
                              <mml:mo>&#x02061;</mml:mo>
                              <mml:mi>min</mml:mi>
                              <mml:mo>&#x02061;</mml:mo>
                           </mml:mrow>
                           <mml:mi mathvariant="bold">w</mml:mi>
                        </mml:munder>
                        <mml:mfrac>
                           <mml:mn>1</mml:mn>
                           <mml:mn>2</mml:mn>
                        </mml:mfrac>
                        <mml:msup>
                           <mml:mrow>
                              <mml:mrow>
                                 <mml:mo>&#x02016;</mml:mo>
                                 <mml:mi mathvariant="bold">w</mml:mi>
                                 <mml:mo>&#x02016;</mml:mo>
                              </mml:mrow>
                           </mml:mrow>
                           <mml:mn>2</mml:mn>
                        </mml:msup>
                        <mml:mo>+</mml:mo>
                        <mml:mfrac>
                           <mml:mi>C</mml:mi>
                           <mml:mi>n</mml:mi>
                        </mml:mfrac>
                        <mml:mstyle displaystyle="true">
                           <mml:munderover>
                              <mml:mo>&#x02211;</mml:mo>
                              <mml:mrow>
                                 <mml:mi>i</mml:mi>
                                 <mml:mo>=</mml:mo>
                                 <mml:mn>1</mml:mn>
                              </mml:mrow>
                              <mml:mi>n</mml:mi>
                           </mml:munderover>
                           <mml:mrow>
                              <mml:msub>
                                 <mml:mi>&#x003be;</mml:mi>
                                 <mml:mi>i</mml:mi>
                              </mml:msub>
                           </mml:mrow>
                        </mml:mstyle>
                        <mml:mtext>&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;</mml:mtext>
                        <mml:mrow>
                           <mml:mo>(</mml:mo>
                           <mml:mrow>
                              <mml:mn>10</mml:mn>
                              <mml:mi>a</mml:mi>
                           </mml:mrow>
                           <mml:mo>)</mml:mo>
                        </mml:mrow>
                     </mml:mrow>
                     <mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaaieqacuWF3bWDgaqcaiabg2da9maaxababaGagiyyaeMaeiOCaiNaei4zaCMagiyBa0MaeiyAaKMaeiOBa4galeaacqWF3bWDaeqaaOWaaSaaaeaacqaIXaqmaeaacqaIYaGmaaWaauWaaeaacqWF3bWDaiaawMa7caGLkWoadaahaaWcbeqaaiabikdaYaaakiabgUcaRmaalaaabaGaem4qameabaGaemOBa4gaamaaqahabaacciGae4NVdG3aaSbaaSqaaiabdMgaPbqabaaabaGaemyAaKMaeyypa0JaeGymaedabaGaemOBa4ganiabggHiLdGccaWLjaGaaCzcamaabmaabaGaeGymaeJaeGimaadcbaGae0xyaegacaGLOaGaayzkaaaaaa@5480@</mml:annotation>
                  </mml:semantics>
               </mml:math></inline-formula></p><p>under the constraints</p><p>&#x02200;<italic>i</italic>, &#x02200;<bold>y </bold>&#x02208; <italic>S</italic><sub><italic>i </italic></sub>: &#x027e8;<bold>w</bold>, &#x00394;&#x003a8;<sub><italic>i</italic></sub>(<bold>y</bold>)&#x027e9; &#x02265; 1 - <italic>&#x003be;</italic><sub><italic>i </italic></sub>with &#x02200;<italic>i </italic>: <italic>&#x003be;</italic><sub><italic>i </italic></sub>&#x02265; 0. &#x000a0;&#x000a0;&#x000a0; (10b)</p><p>The only differences between these constraints and those in equation (9) is that (<italic>i</italic>) the strict inequality (&#x0003e; 0) is replaced by a non-strict inequality (&#x02265; 1), and (<italic>ii</italic>) slack variables <italic>&#x003be;</italic><sub><italic>i </italic></sub>are introduced to allow a best-fit solution in the event of unsatisfiable constraints. The objective function minimizes the length of the weight vector (to normalize the constraints across various dimensions of <bold>w</bold>) and the size of the slack variables. The constant parameter <italic>C </italic>indicates how much a solution is penalized for violating a constraint. In practice, SVMs solve the dual of the minimization problem.</p><p>We can therefore use SVMs to determine our function <italic>G</italic><sub><bold>w</bold></sub>; however, this only solves half of our problem.</p><p>Given a candidate <italic>G</italic><sub><bold>w </bold></sub>we must then determine if equation (3) has been violated and add more constraints to it if necessary. To accomplish this task, we build off of work done by Tsochantaridis et al. [<xref ref-type="bibr" rid="B38">38</xref>] which tightly couples this constraint verification problem with the SVM <bold>w </bold>minimization problem.</p><p>First a loss function &#x00394;(<bold>y</bold><sub><italic>i</italic></sub>, <bold>y</bold>) is defined that weighs the goodness of the structures <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M37" name="1471-2105-8-S5-S3-i1" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mover accent="true"><mml:mi mathvariant="bold">y</mml:mi><mml:mo mathvariant="bold">^</mml:mo></mml:mover><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaaieqacuWF5bqEgaqcaaaa@2E3D@</mml:annotation></mml:semantics></mml:math></inline-formula><sub><italic>i</italic></sub>. Smaller values of &#x00394;(<bold>y</bold><sub><italic>i</italic></sub>, <bold>y</bold>) indicate that structures <bold>y</bold><sub><italic>i </italic></sub>and <bold>y </bold>are more similar. Adding this to the SVM constraints in equation (10b) gives</p><p>&#x02200;<italic>i</italic>, &#x02200;<bold>y </bold>&#x02208; <italic>S</italic><sub><italic>i </italic></sub>: <italic>&#x003be;</italic><sub><italic>i </italic></sub>&#x02265; &#x00394;(<bold>y</bold><sub><italic>i</italic></sub>, <bold>y</bold>) - &#x027e8;<bold>w</bold>, &#x00394;&#x003a8;<sub><italic>i</italic></sub>(<bold>y</bold>)&#x027e9;. &#x000a0;&#x000a0;&#x000a0; (11)</p><p>Using this we can decide when to add constraints to our reduced problem and which constraints to add. Since at every iteration of the algorithm we determine some <bold>w </bold>for the current <italic>S</italic><sub><italic>i</italic></sub>, we can then find the value <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M38" name="1471-2105-8-S5-S3-i10" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mover accent="true"><mml:mi>&#x003be;</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaaiiGacuWF+oaEgaqcaaaa@2E86@</mml:annotation></mml:semantics></mml:math></inline-formula><sub><italic>i </italic></sub>assigned to variable <italic>&#x003be;</italic><sub><italic>i </italic></sub>as a result of the optimization. <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M39" name="1471-2105-8-S5-S3-i10" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mover accent="true"><mml:mi>&#x003be;</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaaiiGacuWF+oaEgaqcaaaa@2E86@</mml:annotation></mml:semantics></mml:math></inline-formula><sub><italic>i </italic></sub>corresponds to the "worst" prediction by <bold>w </bold>across the structures <bold>y </bold>&#x02208; <italic>S</italic><sub><italic>i</italic></sub>:</p><p><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M40" name="1471-2105-8-S5-S3-i11" overflow="scroll">
                  <mml:semantics definitionURL="" encoding="">
                     <mml:mrow>
                        <mml:msub>
                           <mml:mover accent="true">
                              <mml:mi>&#x003be;</mml:mi>
                              <mml:mo>^</mml:mo>
                           </mml:mover>
                           <mml:mi>i</mml:mi>
                        </mml:msub>
                        <mml:mo>=</mml:mo>
                        <mml:mi>max</mml:mi>
                        <mml:mo>&#x02061;</mml:mo>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mn>0</mml:mn>
                        <mml:mo>,</mml:mo>
                        <mml:munder>
                           <mml:mrow>
                              <mml:mi>max</mml:mi>
                              <mml:mo>&#x02061;</mml:mo>
                           </mml:mrow>
                           <mml:mrow>
                              <mml:mi mathvariant="bold">y</mml:mi>
                              <mml:mo>&#x02208;</mml:mo>
                              <mml:msub>
                                 <mml:mi>S</mml:mi>
                                 <mml:mi>i</mml:mi>
                              </mml:msub>
                           </mml:mrow>
                        </mml:munder>
                        <mml:mi>&#x00394;</mml:mi>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:msub>
                           <mml:mi mathvariant="bold">y</mml:mi>
                           <mml:mi>i</mml:mi>
                        </mml:msub>
                        <mml:mo>,</mml:mo>
                        <mml:mi mathvariant="bold">y</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo>&#x02212;</mml:mo>
                        <mml:mrow>
                           <mml:mo>&#x02329;</mml:mo>
                           <mml:mrow>
                              <mml:mi mathvariant="bold">w</mml:mi>
                              <mml:mo>,</mml:mo>
                              <mml:mi>&#x00394;</mml:mi>
                              <mml:msub>
                                 <mml:mi>&#x003a8;</mml:mi>
                                 <mml:mi>i</mml:mi>
                              </mml:msub>
                              <mml:mo stretchy="false">(</mml:mo>
                              <mml:mi mathvariant="bold">y</mml:mi>
                              <mml:mo stretchy="false">)</mml:mo>
                           </mml:mrow>
                           <mml:mo>&#x0232a;</mml:mo>
                        </mml:mrow>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo>.</mml:mo>
                        <mml:mtext>&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;</mml:mtext>
                        <mml:mrow>
                           <mml:mo>(</mml:mo>
                           <mml:mrow>
                              <mml:mn>12</mml:mn>
                           </mml:mrow>
                           <mml:mo>)</mml:mo>
                        </mml:mrow>
                     </mml:mrow>
                     <mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaaiiGacuWF+oaEgaqcamaaBaaaleaacqWGPbqAaeqaaOGaeyypa0JagiyBa0MaeiyyaeMaeiiEaGNaeiikaGIaeGimaaJaeiilaWYaaCbeaeaacyGGTbqBcqGGHbqycqGG4baEaSqaaGqabiab+Lha5jabgIGiolabdofatnaaBaaameaacqWGPbqAaeqaaaWcbeaakiabfs5aejabcIcaOiab+Lha5naaBaaaleaacqWGPbqAaeqaaOGaeiilaWIae4xEaKNaeiykaKIaeyOeI0YaaaWaaeaacqGF3bWDcqGGSaalcqqHuoarcqqHOoqwdaWgaaWcbaGaemyAaKgabeaakiabcIcaOiab+Lha5jabcMcaPaGaayzkJiaawQYiaiabcMcaPiabc6caUiaaxMaacaWLjaWaaeWaaeaacqaIXaqmcqaIYaGmaiaawIcacaGLPaaaaaa@5DB7@</mml:annotation>
                  </mml:semantics>
               </mml:math></inline-formula></p><p>This resulting <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M41" name="1471-2105-8-S5-S3-i10" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mover accent="true"><mml:mi>&#x003be;</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaaiiGacuWF+oaEgaqcaaaa@2E86@</mml:annotation></mml:semantics></mml:math></inline-formula><sub><italic>i</italic></sub>, which was determined using <italic>S</italic><sub><italic>i</italic></sub>, can be compared to a similar <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M42" name="1471-2105-8-S5-S3-i12" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mrow><mml:msub><mml:msup><mml:mover accent="true"><mml:mi>&#x003be;</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaaiiGacuWF+oaEgaqcgaqbamaaBaaaleaacqWGPbqAaeqaaaaa@3018@</mml:annotation></mml:semantics></mml:math></inline-formula> that is obtained by instead maximizing over <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M43" name="1471-2105-8-S5-S3-i3" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">Y</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaat0uy0HwzTfgDPnwy1egaryqtHrhAL1wy0L2yHvdaiqaacqWFyeFwaaa@3850@</mml:annotation></mml:semantics></mml:math></inline-formula>\{<bold>y</bold><sub><italic>i</italic></sub>} in equation (12). This will tell us how much the constraints we are ignoring from <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M44" name="1471-2105-8-S5-S3-i3" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">Y</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaat0uy0HwzTfgDPnwy1egaryqtHrhAL1wy0L2yHvdaiqaacqWFyeFwaaa@3850@</mml:annotation></mml:semantics></mml:math></inline-formula>\{<bold>y</bold><sub><italic>i</italic></sub>} will change the solution. The constraint that is most likely to change the solution is that which would have caused the greatest change to the slack variables. Therefore we would add the constraint to <italic>S</italic><sub><italic>i </italic></sub>that corresponds to</p><p><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M45" name="1471-2105-8-S5-S3-i13" overflow="scroll">
                  <mml:semantics definitionURL="" encoding="">
                     <mml:mrow>
                        <mml:msup>
                           <mml:mover accent="true">
                              <mml:mi mathvariant="bold">y</mml:mi>
                              <mml:mo mathvariant="bold">^</mml:mo>
                           </mml:mover>
                           <mml:mo>&#x02032;</mml:mo>
                        </mml:msup>
                        <mml:mo>=</mml:mo>
                        <mml:munder>
                           <mml:mrow>
                              <mml:mi>arg</mml:mi>
                              <mml:mo>&#x02061;</mml:mo>
                              <mml:mi>max</mml:mi>
                              <mml:mo>&#x02061;</mml:mo>
                           </mml:mrow>
                           <mml:mrow>
                              <mml:mi mathvariant="bold">y</mml:mi>
                              <mml:mo>&#x02208;</mml:mo>
                              <mml:mi mathvariant="script">Y</mml:mi>
                              <mml:mo>\</mml:mo>
                              <mml:mo>{</mml:mo>
                              <mml:msub>
                                 <mml:mi mathvariant="bold">y</mml:mi>
                                 <mml:mi mathvariant="bold">i</mml:mi>
                              </mml:msub>
                              <mml:mo>}</mml:mo>
                           </mml:mrow>
                        </mml:munder>
                        <mml:mi>&#x00394;</mml:mi>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:msub>
                           <mml:mi mathvariant="bold">y</mml:mi>
                           <mml:mi mathvariant="bold">i</mml:mi>
                        </mml:msub>
                        <mml:mo>,</mml:mo>
                        <mml:mi mathvariant="bold">y</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo>&#x02212;</mml:mo>
                        <mml:mrow>
                           <mml:mo>&#x02329;</mml:mo>
                           <mml:mrow>
                              <mml:mi mathvariant="bold">w</mml:mi>
                              <mml:mo>,</mml:mo>
                              <mml:mi>&#x00394;</mml:mi>
                              <mml:msub>
                                 <mml:mi>&#x003a8;</mml:mi>
                                 <mml:mi>i</mml:mi>
                              </mml:msub>
                              <mml:mo stretchy="false">(</mml:mo>
                              <mml:mi mathvariant="bold">y</mml:mi>
                              <mml:mo stretchy="false">)</mml:mo>
                           </mml:mrow>
                           <mml:mo>&#x0232a;</mml:mo>
                        </mml:mrow>
                        <mml:mo>.</mml:mo>
                        <mml:mtext>&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;</mml:mtext>
                        <mml:mrow>
                           <mml:mo>(</mml:mo>
                           <mml:mrow>
                              <mml:mn>13</mml:mn>
                           </mml:mrow>
                           <mml:mo>)</mml:mo>
                        </mml:mrow>
                     </mml:mrow>
                     <mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaaieqacuWF5bqEgaqcgaqbaiabg2da9maaxababaGagiyyaeMaeiOCaiNaei4zaCMagiyBa0MaeiyyaeMaeiiEaGhaleaacqWF5bqEcqGHiiIZt0uy0HwzTfgDPnwy1egaryqtHrhAL1wy0L2yHvdaiqaacqGFyeFwcqGGCbaxcqGG7bWEcqWF5bqEdaWgaaadbaGaemyAaKgabeaaliabc2ha9bqabaGccqqHuoarcqGGOaakcqWF5bqEdaWgaaWcbaGaemyAaKgabeaakiabcYcaSiab=Lha5jabcMcaPiabgkHiTmaaamaabaGae83DaCNaeiilaWIaeuiLdqKaeuiQdK1aaSbaaSqaaiabdMgaPbqabaGccqGGOaakcqWF5bqEcqGGPaqkaiaawMYicaGLQmcacqGGUaGlcaWLjaGaaCzcamaabmaabaGaeGymaeJaeG4mamdacaGLOaGaayzkaaaaaa@6878@</mml:annotation>
                  </mml:semantics>
               </mml:math></inline-formula></p><p>Tsochantaridis et al. [<xref ref-type="bibr" rid="B38">38</xref>] show that by only adding constraints when <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M46" name="1471-2105-8-S5-S3-i1" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mover accent="true"><mml:mi mathvariant="bold">y</mml:mi><mml:mo mathvariant="bold">^</mml:mo></mml:mover><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaaieqacuWF5bqEgaqcaaaa@2E3D@</mml:annotation></mml:semantics></mml:math></inline-formula>' could change <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M47" name="1471-2105-8-S5-S3-i10" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mover accent="true"><mml:mi>&#x003be;</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaaiiGacuWF+oaEgaqcaaaa@2E86@</mml:annotation></mml:semantics></mml:math></inline-formula> by more than <italic>&#x003b5;</italic>, one can attain a provable termination condition for the problem. The summary of this overall algorithm appears in Figure <xref ref-type="fig" rid="F5">5</xref>.</p></sec><sec><title>Defining the set of valid structures</title><p>One final issue remains to be solved to complete our algorithm. We need to specify what <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M48" name="1471-2105-8-S5-S3-i3" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">Y</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaat0uy0HwzTfgDPnwy1egaryqtHrhAL1wy0L2yHvdaiqaacqWFyeFwaaa@3850@</mml:annotation></mml:semantics></mml:math></inline-formula> and &#x003a8;(<bold>x</bold>, <bold>y</bold>) are, and how to optimize <italic>G</italic>(<bold>x</bold>, <bold>y</bold>) over <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M49" name="1471-2105-8-S5-S3-i3" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">Y</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaat0uy0HwzTfgDPnwy1egaryqtHrhAL1wy0L2yHvdaiqaacqWFyeFwaaa@3850@</mml:annotation></mml:semantics></mml:math></inline-formula>. In general, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M50" name="1471-2105-8-S5-S3-i3" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">Y</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaat0uy0HwzTfgDPnwy1egaryqtHrhAL1wy0L2yHvdaiqaacqWFyeFwaaa@3850@</mml:annotation></mml:semantics></mml:math></inline-formula> can be exponentially large with respect to the sequence length, making brute-force optimization impractical. Our general approach is to structure <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M51" name="1471-2105-8-S5-S3-i3" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">Y</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaat0uy0HwzTfgDPnwy1egaryqtHrhAL1wy0L2yHvdaiqaacqWFyeFwaaa@3850@</mml:annotation></mml:semantics></mml:math></inline-formula> and &#x003a8;(<bold>x</bold>, <bold>y</bold>) in a way that allows optimization of <italic>G</italic>(<bold>x</bold>, <bold>y</bold>) through dynamic programming.</p><p>Most secondary-structure prediction tools use local features to predict which regions of a protein will be helical [<xref ref-type="bibr" rid="B2">2</xref>]. Individual residues can have propensities for being in a helix, they can act as helix nucleation sites, or they can interact with other nearby residues. This type of information can be well captured by Hidden Markov Models (HMMs). Equivalently, we choose to capture them using Finite State Machines (FSMs). The only difference between the FSMs we use and a non-stationary HMM is that the HMM deals with probabilities, which are multiplicative, while our FSMs deal with pseudo-energies, which are additive. To a logarithm, they are the same.</p><p>We define <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M52" name="1471-2105-8-S5-S3-i3" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">Y</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaat0uy0HwzTfgDPnwy1egaryqtHrhAL1wy0L2yHvdaiqaacqWFyeFwaaa@3850@</mml:annotation></mml:semantics></mml:math></inline-formula> to be the language that is recognized by some FSM. Thus a structure <bold>y </bold>&#x02208; <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M53" name="1471-2105-8-S5-S3-i3" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">Y</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaat0uy0HwzTfgDPnwy1egaryqtHrhAL1wy0L2yHvdaiqaacqWFyeFwaaa@3850@</mml:annotation></mml:semantics></mml:math></inline-formula> will be a string over the input alphabet of the FSM. For example, that alphabet could be {<italic>h</italic>, <italic>c</italic>}, where <italic>h </italic>indicates that the residue at that position in the string is in a helix, and <italic>c </italic>indicates that it is in a coil region. A string <bold>y </bold>is read by an FSM one character at a time, inducing a specific set of transitions between internal states. Note that the FSMs we are considering do not need to be deterministic. However, they do need to satisfy the property that, for a given input string, there is at most one set of transitions leading from the initial state to a final state. We denote this sequence of transitions by <italic>&#x003c3;</italic>(<bold>y</bold>) and note that <italic>&#x003c3;</italic>(<bold>y</bold>) need not be defined for all <bold>y</bold>.</p><p>To define &#x003a8;(<bold>x</bold>, <bold>y</bold>), we create a helper function <italic>&#x003c8;</italic>(<bold>x</bold>, <italic>t</italic>, <italic>i</italic>) which assigns a vector of feature values whenever transition <italic>t </italic>is taken at position <italic>i </italic>in the sequence <bold>x</bold>. For example, if a transition is taken to start a helix at position <italic>i</italic>, then <italic>&#x003c8;</italic>(<bold>x</bold>, <italic>t</italic>, <italic>i</italic>) might return features indicating that residues at position <italic>i </italic>- 3 to <italic>i </italic>+ 3 are associated with an N-terminal helix cap. The overall feature vector is the sum of these features across all positions in the sequence: &#x003a8;(<bold>x</bold>, <bold>y</bold>) = &#x02211;<sub><italic>i </italic></sub><italic>&#x003c8;</italic>(<bold>x</bold>, <italic>&#x003c3; </italic>(<bold>y</bold>)<italic>i</italic>, <italic>i</italic>).</p><p>The total cost <italic>G</italic>(<bold>x</bold>, <bold>y</bold>) follows the form of equation (7). We also specify an infinite cost for structures that are the wrong length or are rejected by the FSM:</p><p><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M54" name="1471-2105-8-S5-S3-i14" overflow="scroll">
                  <mml:semantics definitionURL="" encoding="">
                     <mml:mrow>
                        <mml:mi>G</mml:mi>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mi>x</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:mi>y</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:mrow>
                           <mml:mo>{</mml:mo>
                           <mml:mrow>
                              <mml:mtable columnalign="left">
                                 <mml:mtr columnalign="left">
                                    <mml:mtd columnalign="left">
                                       <mml:mrow>
                                          <mml:mo>+</mml:mo>
                                          <mml:mi>&#x0221e;</mml:mi>
                                       </mml:mrow>
                                    </mml:mtd>
                                    <mml:mtd columnalign="left">
                                       <mml:mrow>
                                          <mml:mtext>if&#x000a0;</mml:mtext>
                                          <mml:mrow>
                                             <mml:mo>|</mml:mo>
                                             <mml:mi>x</mml:mi>
                                             <mml:mo>|</mml:mo>
                                          </mml:mrow>
                                          <mml:mo>&#x02260;</mml:mo>
                                          <mml:mrow>
                                             <mml:mo>|</mml:mo>
                                             <mml:mi>y</mml:mi>
                                             <mml:mo>|</mml:mo>
                                          </mml:mrow>
                                          <mml:mtext>&#x000a0;or&#x000a0;</mml:mtext>
                                          <mml:mi>&#x003c3;</mml:mi>
                                          <mml:mo stretchy="false">(</mml:mo>
                                          <mml:mi>y</mml:mi>
                                          <mml:mo stretchy="false">)</mml:mo>
                                          <mml:mi/>
                                          <mml:mtext>is un</mml:mtext>
                                          <mml:mi/>
                                          <mml:mtext>defined</mml:mtext>
                                       </mml:mrow>
                                    </mml:mtd>
                                 </mml:mtr>
                                 <mml:mtr columnalign="left">
                                    <mml:mtd columnalign="left">
                                       <mml:mrow>
                                          <mml:mrow>
                                             <mml:mo>&#x02329;</mml:mo>
                                             <mml:mrow>
                                                <mml:mi>w</mml:mi>
                                                <mml:mo>,</mml:mo>
                                                <mml:mi>&#x003a8;</mml:mi>
                                                <mml:mo stretchy="false">(</mml:mo>
                                                <mml:mi>x</mml:mi>
                                                <mml:mo>,</mml:mo>
                                                <mml:mi>y</mml:mi>
                                                <mml:mo stretchy="false">)</mml:mo>
                                             </mml:mrow>
                                             <mml:mo>&#x0232a;</mml:mo>
                                          </mml:mrow>
                                       </mml:mrow>
                                    </mml:mtd>
                                    <mml:mtd columnalign="left">
                                       <mml:mrow>
                                          <mml:mi>o</mml:mi>
                                          <mml:mi>t</mml:mi>
                                          <mml:mi>h</mml:mi>
                                          <mml:mi>e</mml:mi>
                                          <mml:mi>r</mml:mi>
                                          <mml:mi>w</mml:mi>
                                          <mml:mi>i</mml:mi>
                                          <mml:mi>s</mml:mi>
                                          <mml:mi>e</mml:mi>
                                       </mml:mrow>
                                    </mml:mtd>
                                 </mml:mtr>
                              </mml:mtable>
                           </mml:mrow>
                        </mml:mrow>
                        <mml:mtext>&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;</mml:mtext>
                        <mml:mrow>
                           <mml:mo>(</mml:mo>
                           <mml:mrow>
                              <mml:mn>14</mml:mn>
                           </mml:mrow>
                           <mml:mo>)</mml:mo>
                        </mml:mrow>
                     </mml:mrow>
                     <mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaacqWGhbWrcqGGOaakieqacqWF4baEcqGGSaalcqWF5bqEcqGGPaqkcqGH9aqpdaGabaqaauaabaaaciaaaeaacqGHRaWkcqGHEisPaeaacqqGPbqAcqqGMbGzcqqGGaaidaabdaqaaiab=Hha4bGaay5bSlaawIa7aiabgcMi5oaaemaabaGae8xEaKhacaGLhWUaayjcSdGaeeiiaaIaee4Ba8MaeeOCaiNaeeiiaaccciGae43WdmNaeiikaGIae8xEaKNae8xkaKcccaGae0hiaaIaeeyAaKMaee4CamhcbiGaeWhiaaIaeeizaqMaeeyzauMaeeOzayMaeeyAaKMaeeOBa4MaeeyzauMaeeizaqgabaWaaaWaaeaacqWG3bWDcqGGSaalcqqHOoqwcqGGOaakcqWF4baEcqGGSaalcqWF5bqEcqGGPaqkaiaawMYicaGLQmcaaeaaieaacqWEVbWBcqWE0baDcqWEObaAcqWELbqzcqWEYbGCcqWE3bWDcqWEPbqAcqWEZbWCcqWELbqzaaaacaGL7baacaWLjaGaaCzcamaabmaabaGaeGymaeJaeGinaqdacaGLOaGaayzkaaaaaa@795F@</mml:annotation>
                  </mml:semantics>
               </mml:math></inline-formula></p><p>This cost is easy to optimize over <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M55" name="1471-2105-8-S5-S3-i3" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">Y</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaat0uy0HwzTfgDPnwy1egaryqtHrhAL1wy0L2yHvdaiqaacqWFyeFwaaa@3850@</mml:annotation></mml:semantics></mml:math></inline-formula> by using the Viterbi algorithm. This algorithm proceeds in |<bold>x</bold>| rounds. In round <italic>i</italic>, the best path of length <italic>s </italic>starting from an initial state is calculated for each FSM state. These paths are computed by extending the best paths from the previous round by one transition, and picking the best resulting path for each state. The algorithmic complexity is <italic>O</italic>(|<italic>FSM</italic>|&#x000b7;|<bold>x</bold>|), where |<italic>FSM</italic>| is the number of states and transitions in the FSM.</p></sec><sec><title>Implementation of the predictor</title><p>In our experiments, we have used an extremely simple finite state machine that is presented in Figure <xref ref-type="fig" rid="F1">1</xref>. Each state corresponds to being in a helix or coil region, and indicates how far into the region we are. States H4 and C3 correspond to helices and coils more than 4 and 3 residues long, respectively. Short coils are permitted, but helices shorter than 4 residues are not allowed, as even 3<sub>10 </sub>helices need at least 4 residues to complete one turn and form the first hydrogen bond.</p><p>Table <xref ref-type="table" rid="T3">3</xref> lists the basic features that were used in our experiments. These features can also be considered to be the parameters of our system, as our learning algorithm assigns an appropriate weight to each one. Our choice of features is motivated by observations that amino acids have varying propensities for appearing within an alpha helix as well as for appearing at the ends of a helix, an area termed the helix cap [<xref ref-type="bibr" rid="B39">39</xref>]. We introduce a single feature per residue to account for helix propensity, for a total of 20 parameters. For helix capping, we use a separate feature for each residue that appears at a given offset (-3 to +3) from a given end of the helix (N-terminal or C-terminal). This accounts for 20 * 7 * 2 = 280 parameters. Finally, we also introduce a feature for very short (2-residue) and short (3-residue) coils. Thus, there are a total of 302 parameters.</p><p>Table <xref ref-type="table" rid="T4">4</xref> illustrates how features are associated with the transitions of the FSM. This table corresponds to the <italic>&#x003c8; </italic>function described earlier; given an FSM transition and a position in the input sequence, it outputs a set of representative features. Most of this mapping is straightforward. In the case of helix caps (labels #1 and #2), features are emitted across a 7-residue window that is centered at position <italic>n </italic>- 1 (the previously processed residue).</p><p>None of the features we have used involve more than one residue in the sequence. We have experimented with more complicated cost functions that model pairwise interactions between nearby residues in a helix, namely between <italic>n </italic>and <italic>n </italic>+ 3 or <italic>n </italic>and <italic>n </italic>+ 4. So far we have not managed to improve our prediction accuracy using these interactions, possibly because each pairwise interaction adds 400 features to the cost function, leaving much room for over-learning. Indeed, with the expanded cost functions we observed improved predictions on the training proteins, but decreased performance on the test proteins.</p><p>We have also experimented with various loss functions &#x00394;. We have tried a 0&#x02013;1 loss function (0 unless both structures are identical), hamming distance (number of incorrectly predicted residues), and a modified hamming distance (residues are given more weight when they are farther from the helix-coil transitions). Each one gives results slightly better than the previous one.</p></sec></sec><sec><title>Competing interests</title><p>The authors declare that they have no competing interests.</p></sec><sec><title>Authors' contributions</title><p>BG participated in the design of the method, implemented the bulk of the software, and drafted much of the manuscript. CWO participated in the design of the method, helped to implement the software, and drafted much of the manuscript. WT participated in the design of the method, helped to implement the software, and drafted much of the manuscript. AL refined the HMM cost models used for prediction. MvD participated in the design of the method and helped to draft the manuscript. SD initiated the project, participated in the design of the method, coordinated, and helped to draft the manuscript. All authors read and approved the final manuscript.</p></sec></body><back><ack><sec><title>Acknowledgements</title><p>We thank Chris Batten, Edward Suh and Rodric Rabbah for their early contributions to this work. WT also thanks Saman Amarasinghe for supporting his part in this research.</p><p>This article has been published as part of <italic>BMC Bioinformatics </italic>Volume 8, Supplement 5, 2007: Articles selected from posters presented at the Tenth Annual International Conference on Research in Computational Biology. The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/8?issue=S5"/>.</p></sec></ack><ref-list><ref id="B1"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Eyrich</surname><given-names>V</given-names></name><etal></etal></person-group><article-title>EVA: Continuous automatic evaluation of protein structure prediction servers</article-title><source>Bioinformatics</source><year>2001</year><volume>17</volume><fpage>1242</fpage><lpage>1243</lpage><pub-id pub-id-type="pmid">11751240</pub-id></citation></ref><ref id="B2"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Rost</surname><given-names>B</given-names></name></person-group><article-title>Review: Protein Secondary Structure Prediction Continues to Rise</article-title><source>Journal of Structural Biology</source><year>2001</year><volume>134</volume><fpage>204</fpage><lpage>218</lpage><pub-id pub-id-type="pmid">11551180</pub-id></citation></ref><ref id="B3"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Zemla</surname><given-names>A</given-names></name><name><surname>Ceslovas</surname><given-names>Venclovas</given-names></name><name><surname>Fidelis</surname><given-names>K</given-names></name><name><surname>Rost</surname><given-names>B</given-names></name></person-group><article-title>A Modified Definition of Sov, a Segment-Based Measure for Protein Secondary Structure Prediction Assessment</article-title><source>Proteins</source><year>1999</year><volume>34</volume><fpage>220</fpage><lpage>223</lpage><pub-id pub-id-type="pmid">10022357</pub-id></citation></ref><ref id="B4"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Jones</surname><given-names>DT</given-names></name></person-group><article-title>Protein Secondary Structure Prediction Based on Position-specific Scoring Matrices</article-title><source>Journal of Molecular Biology</source><year>1999</year><volume>292</volume><fpage>195</fpage><lpage>202</lpage><pub-id pub-id-type="pmid">10493868</pub-id></citation></ref><ref id="B5"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Nguyen</surname><given-names>MN</given-names></name><name><surname>Rajapakse</surname><given-names>JC</given-names></name></person-group><article-title>Prediction of protein secondary structure using bayesian method and support vector machines</article-title><source>ICONIP</source><year>2002</year></citation></ref><ref id="B6"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>King</surname><given-names>RD</given-names></name><name><surname>Sternberg</surname><given-names>MJ</given-names></name></person-group><article-title>Identification and application of the concepts important for accurate and reliable protein secondary structure prediction</article-title><source>Protein science</source><year>1996</year><volume>5</volume><fpage>2298</fpage><lpage>2310</lpage><pub-id pub-id-type="pmid">8931148</pub-id></citation></ref><ref id="B7"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Garnier</surname><given-names>J</given-names></name><name><surname>Osguthorpe</surname><given-names>D</given-names></name><name><surname>Robson</surname><given-names>B</given-names></name></person-group><article-title>Analysis of the accuracy and implications of simple methods for predicting the secondary structure of globular proteins</article-title><source>Journal of Molecular Biology</source><year>1978</year><volume>120</volume><fpage>97</fpage><lpage>120</lpage><pub-id pub-id-type="pmid">642007</pub-id></citation></ref><ref id="B8"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Levin</surname><given-names>J</given-names></name><name><surname>Pascarella</surname><given-names>S</given-names></name><name><surname>Argos</surname><given-names>P</given-names></name><name><surname>Garnier</surname><given-names>J</given-names></name></person-group><article-title>Quantification of secondary structure prediction improvement using multiple alignments</article-title><source>Protein Engineering</source><year>1993</year><volume>6</volume><fpage>849</fpage><lpage>854</lpage><pub-id pub-id-type="pmid">8309932</pub-id></citation></ref><ref id="B9"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Rost</surname><given-names>B</given-names></name><name><surname>Sander</surname><given-names>C</given-names></name></person-group><article-title>Prediction of protein secondary structure at better than 70% accuracy</article-title><source>Journal of Molecular Biology</source><year>1993</year><volume>232</volume><fpage>584</fpage><lpage>599</lpage><pub-id pub-id-type="pmid">8345525</pub-id></citation></ref><ref id="B10"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Riis</surname><given-names>S</given-names></name><name><surname>Krogh</surname><given-names>A</given-names></name></person-group><article-title>Improving prediction of protein secondary structure using structured neural networks and multiple sequence alignments</article-title><source>Journal of Computational Biology</source><year>1996</year><volume>3</volume><fpage>163</fpage><lpage>183</lpage><pub-id pub-id-type="pmid">8697234</pub-id></citation></ref><ref id="B11"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Altun</surname><given-names>Y</given-names></name><name><surname>Tsochantaridis</surname><given-names>I</given-names></name><name><surname>Hofmann</surname><given-names>T</given-names></name></person-group><article-title>Hidden Markov Support Vector Machines</article-title><source>ICML'03: Proceedings of the 20th International Conference on Machine Learning</source><year>2003</year></citation></ref><ref id="B12"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Tsochantaridis</surname><given-names>I</given-names></name><name><surname>Altun</surname><given-names>Y</given-names></name><name><surname>Hoffman</surname><given-names>T</given-names></name></person-group><article-title>A crossover between SVMs and HMMs for protein structure prediction</article-title><source>NIPS Workshop on Machine Learning Techniques for Bioinformatics</source><year>2002</year></citation></ref><ref id="B13"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Nguyen</surname><given-names>MN</given-names></name><name><surname>Rajapakse</surname><given-names>JC</given-names></name></person-group><article-title>Prediction of protein secondary structure using bayesian method and support vector machines</article-title><source>9th International Conference on Neural Information Processing</source><year>2002</year></citation></ref><ref id="B14"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Bystroff</surname><given-names>C</given-names></name><name><surname>Thorsson</surname><given-names>V</given-names></name><name><surname>Baker</surname><given-names>D</given-names></name></person-group><article-title>HMMSTR: a Hidden Markov Model for Local Sequence-Structure Correlations in Proteins</article-title><source>Journal of Molecular Biology</source><year>2000</year><volume>301</volume><pub-id pub-id-type="pmid">10926500</pub-id></citation></ref><ref id="B15"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Martin</surname><given-names>J</given-names></name><name><surname>Gibrat</surname><given-names>JF</given-names></name><name><surname>Rodolphe</surname><given-names>F</given-names></name></person-group><article-title>Hidden Markov Model for protein secondary structure</article-title><source>International Symposium on Applied Stochastic Models and Data Analysis</source><year>2005</year></citation></ref><ref id="B16"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Won</surname><given-names>K</given-names></name><name><surname>Hamelryck</surname><given-names>T</given-names></name><name><surname>Pr&#x000fc;gel-Bennett</surname><given-names>A</given-names></name><name><surname>Krogh</surname><given-names>A</given-names></name></person-group><article-title>Evolving Hidden Markov Models for Protein Secondary Structure Prediction</article-title><source>Proceedings of IEEE Congress on Evolutionary Computation</source><year>2005</year><fpage>33</fpage><lpage>40</lpage></citation></ref><ref id="B17"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Won</surname><given-names>KJ</given-names></name><name><surname>Pr&#x000fc;gel-Bennett</surname><given-names>A</given-names></name><name><surname>Krogh</surname><given-names>A</given-names></name></person-group><article-title>Training HMM Structure with Genetic Algorithm for Biological Sequence Analysis</article-title><source>Bioinformatics</source><year>2004</year><volume>20</volume><fpage>3613</fpage><lpage>3627</lpage><pub-id pub-id-type="pmid">15297297</pub-id></citation></ref><ref id="B18"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Schmidler</surname><given-names>SC</given-names></name><name><surname>Liu</surname><given-names>JS</given-names></name><name><surname>Brutlag</surname><given-names>DL</given-names></name></person-group><article-title>Bayesian Segmentation of Protein Secondary Structure</article-title><source>Journal of Computational Biology</source><year>2000</year><volume>7</volume><fpage>233</fpage><lpage>248</lpage><pub-id pub-id-type="pmid">10890399</pub-id></citation></ref><ref id="B19"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Schmidler</surname><given-names>SC</given-names></name><name><surname>Liu</surname><given-names>JS</given-names></name><name><surname>Brutlag</surname><given-names>DL</given-names></name></person-group><article-title>Bayesian Protein Structure Prediction</article-title><source>Case Studies in Bayesian Statistics</source><year>2001</year><volume>5</volume><fpage>363</fpage><lpage>378</lpage></citation></ref><ref id="B20"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Chu</surname><given-names>W</given-names></name><name><surname>Ghahramani</surname><given-names>Z</given-names></name></person-group><article-title>Protein Secondary Structure Prediction Using Sigmoid Belief Networks to Parameterize Segmental Semi-Markov Models</article-title><source>European Symposium on Artificial Neural Networks Bruges (Belgium)</source><year>2004</year><fpage>81</fpage><lpage>86</lpage></citation></ref><ref id="B21"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Krogh</surname><given-names>A</given-names></name><name><surname>Larsson</surname><given-names>B</given-names></name><name><surname>von Heijne</surname><given-names>G</given-names></name><name><surname>Sonnhammer</surname><given-names>E</given-names></name></person-group><article-title>Predicting transmembrane protein topology with a hidden markov model: application to complete genomes</article-title><source>Journal of Molecular Biology</source><year>2001</year><volume>305</volume><fpage>567</fpage><lpage>580</lpage><pub-id pub-id-type="pmid">11152613</pub-id></citation></ref><ref id="B22"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Qian</surname><given-names>N</given-names></name><name><surname>Sejnowski</surname><given-names>T</given-names></name></person-group><article-title>Predicting the secondary structure of globular proteins using neural network models</article-title><source>Journal of Molecular Biology</source><year>1988</year><volume>202</volume><fpage>865</fpage><lpage>884</lpage><pub-id pub-id-type="pmid">3172241</pub-id></citation></ref><ref id="B23"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Baldi</surname><given-names>P</given-names></name><name><surname>Brunak</surname><given-names>S</given-names></name><name><surname>Frasconi</surname><given-names>P</given-names></name><name><surname>Soda</surname><given-names>G</given-names></name><name><surname>Pollastri</surname><given-names>G</given-names></name></person-group><article-title>Exploiting the past and the future in protein secondary structure prediction</article-title><source>Bioinformatics</source><year>1999</year><volume>15</volume><fpage>937</fpage><lpage>946</lpage><pub-id pub-id-type="pmid">10743560</pub-id></citation></ref><ref id="B24"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Pollastri</surname><given-names>G</given-names></name><name><surname>McLysaght</surname><given-names>A</given-names></name></person-group><article-title>Porter: a new, accurate server for protein secondary structure prediction</article-title><source>Bioinformatics</source><year>2005</year><volume>21</volume><fpage>1719</fpage><lpage>1720</lpage><pub-id pub-id-type="pmid">15585524</pub-id></citation></ref><ref id="B25"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Petersen</surname><given-names>TN</given-names></name><name><surname>Lundegaard</surname><given-names>C</given-names></name><name><surname>Nielsen</surname><given-names>M</given-names></name><name><surname>Bohr</surname><given-names>H</given-names></name><name><surname>Bohr</surname><given-names>J</given-names></name><name><surname>Brunak</surname><given-names>S</given-names></name><name><surname>Gippert</surname><given-names>GP</given-names></name><name><surname>Lund</surname><given-names>O</given-names></name></person-group><article-title>Prediction of Protein Secondary Structure at 80% Accuracy</article-title><source>PROTEINS: Structure, Function, and Genetics</source><year>2000</year><volume>14</volume><fpage>17</fpage><lpage>20</lpage></citation></ref><ref id="B26"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Lin</surname><given-names>K</given-names></name><name><surname>Simossis</surname><given-names>VA</given-names></name><name><surname>Taylor</surname><given-names>WR</given-names></name><name><surname>Heringa</surname><given-names>J</given-names></name></person-group><article-title>A simple and fast secondary structure prediction method using hidden neural networks</article-title><source>Bioinformatics</source><year>2005</year><volume>21</volume><fpage>152</fpage><lpage>159</lpage><pub-id pub-id-type="pmid">15377504</pub-id></citation></ref><ref id="B27"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Ouali</surname><given-names>M</given-names></name><name><surname>King</surname><given-names>RD</given-names></name></person-group><article-title>Cascaded multiple classifiers for secondary structure prediction</article-title><source>Protein Science</source><year>2000</year><volume>9</volume><fpage>1162</fpage><lpage>1176</lpage><pub-id pub-id-type="pmid">10892809</pub-id></citation></ref><ref id="B28"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Eyrich</surname><given-names>V</given-names></name><name><surname>Marti-Renom</surname><given-names>M</given-names></name><name><surname>Przybylski</surname><given-names>D</given-names></name><name><surname>Madhusudhan</surname><given-names>M</given-names></name><name><surname>Fiser</surname><given-names>A</given-names></name><name><surname>Pazos</surname><given-names>F</given-names></name><name><surname>Valencia</surname><given-names>A</given-names></name><name><surname>Sali</surname><given-names>A</given-names></name><name><surname>Rost</surname><given-names>B</given-names></name></person-group><article-title>EVA: Continuous automatic evaluation of protein structure prediction servers</article-title><source>Bioinformatics</source><year>2001</year><volume>17</volume><fpage>1242</fpage><lpage>1243</lpage><pub-id pub-id-type="pmid">11751240</pub-id></citation></ref><ref id="B29"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Nguyen</surname><given-names>MN</given-names></name><name><surname>Rajapakse</surname><given-names>JC</given-names></name></person-group><article-title>Multi-Class Support Vector Machines for Protein Secondary Structure Prediction</article-title><source>Genome Informatics</source><year>2003</year><volume>14</volume><fpage>218</fpage><lpage>227</lpage><pub-id pub-id-type="pmid">15706536</pub-id></citation></ref><ref id="B30"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Ward</surname><given-names>J</given-names></name><name><surname>McGuffin</surname><given-names>L</given-names></name><name><surname>Buxton</surname><given-names>B</given-names></name><name><surname>Jones</surname><given-names>D</given-names></name></person-group><article-title>Secondary structure prediction with support vector machines</article-title><source>Bioinformatics</source><year>2003</year><volume>19</volume><fpage>1650</fpage><lpage>1655</lpage><pub-id pub-id-type="pmid">12967961</pub-id></citation></ref><ref id="B31"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Ceroni</surname><given-names>A</given-names></name><name><surname>Frasconi</surname><given-names>P</given-names></name><name><surname>Passerini</surname><given-names>A</given-names></name><name><surname>Vullo</surname><given-names>A</given-names></name></person-group><article-title>A Combination of Support Vector Machines and Bidirectional Recurrent Neural Networks for Protein Secondary Structure Predict</article-title><source>Advances in Artificial Intelligence, 8th Congress of the Italian Association for Artificial Intelligence</source><year>2003</year><volume>2829</volume><fpage>142</fpage><lpage>153</lpage></citation></ref><ref id="B32"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Casborn</surname><given-names>J</given-names></name></person-group><article-title>Protein Secondary Structure Class Prediction with Support Vector Machines</article-title><source>MSc Dissertation</source><year>2002</year><publisher-name>University of Sussex</publisher-name></citation></ref><ref id="B33"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Hua</surname><given-names>S</given-names></name><name><surname>Sun</surname><given-names>Z</given-names></name></person-group><article-title>A Novel Method of Protein Secondary Structure Prediction with High Segment Overlap Measure: Support Vector Machine Approach</article-title><source>Journal of Molecular Biology</source><year>2001</year><volume>308</volume><fpage>397</fpage><lpage>407</lpage><pub-id pub-id-type="pmid">11327775</pub-id></citation></ref><ref id="B34"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Hu</surname><given-names>HJ</given-names></name><name><surname>Pan</surname><given-names>Y</given-names></name><name><surname>Harrison</surname><given-names>R</given-names></name><name><surname>Tai</surname><given-names>PC</given-names></name></person-group><article-title>Improved Protein Secondary Structure Prediction Using Support Vector Machine With a New Encoding Scheme and an Advanced Tertiary Classifier</article-title><source>IEEE Transactions on Nanobioscience</source><year>2004</year><volume>3</volume><fpage>265</fpage><lpage>271</lpage><pub-id pub-id-type="pmid">15631138</pub-id></citation></ref><ref id="B35"><citation citation-type="other"><article-title>EVA Largest sequence of unique subset of PDB</article-title><ext-link ext-link-type="uri" xlink:href="http://salilab.org/~eva/res/weeks.html#unique"/></citation></ref><ref id="B36"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Kabsch</surname><given-names>W</given-names></name><name><surname>Sander</surname><given-names>C</given-names></name></person-group><article-title>Dictionary of protein secondary structure</article-title><source>Biopolymers</source><year>1983</year><volume>22</volume><pub-id pub-id-type="pmid">6667333</pub-id></citation></ref><ref id="B37"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Berman</surname><given-names>H</given-names></name><name><surname>Westbrook</surname><given-names>J</given-names></name><name><surname>Feng</surname><given-names>Z</given-names></name><name><surname>Gilliland</surname><given-names>G</given-names></name><name><surname>Bhat</surname><given-names>T</given-names></name><name><surname>Weissig</surname><given-names>H</given-names></name><name><surname>Shindyalov</surname><given-names>I</given-names></name><name><surname>Bourne</surname><given-names>P</given-names></name></person-group><article-title>The Protein Data Bank</article-title><source>Nucleic Acids Research</source><year>2000</year><volume>28</volume><pub-id pub-id-type="pmid">10592235</pub-id></citation></ref><ref id="B38"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Tsochantaridis</surname><given-names>I</given-names></name><name><surname>Hofmann</surname><given-names>T</given-names></name><name><surname>Joachims</surname><given-names>T</given-names></name><name><surname>Altun</surname><given-names>Y</given-names></name></person-group><article-title>Support Vector Machine Learning for Interdependent and Structured Output Spaces</article-title><source>ICML</source><year>2004</year></citation></ref><ref id="B39"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Aurora</surname><given-names>R</given-names></name><name><surname>Rose</surname><given-names>G</given-names></name></person-group><article-title>Helix capping</article-title><source>Protein Science</source><year>1998</year><volume>7</volume><pub-id pub-id-type="pmid">9514257</pub-id></citation></ref></ref-list><sec sec-type="display-objects"><title>Figures and Tables</title><fig position="float" id="F1"><label>Figure 1</label><caption><p><bold>Predictor finite state machine</bold>. Double circles represent accept states. The arrow leading into state C3 indicates that it is an initial state. Each transition is labeled with the type of structure it corresponds to: helix (H) or coil (C), and a label (#i) indicating which features correspond to this transition in Table 4.</p></caption><graphic xlink:href="1471-2105-8-S5-S3-1"/></fig><fig position="float" id="F2"><label>Figure 2</label><caption><p><bold>Q<sub><italic>&#x003b1; </italic></sub>accuracy histogram</bold>. Histogram showing the distribution of Q<sub><italic>&#x003b1; </italic></sub>across proteins in the test set. We have shown the average case, and the best of the 20 runs which has the highest Q<sub><italic>&#x003b1;</italic></sub>.</p></caption><graphic xlink:href="1471-2105-8-S5-S3-2"/></fig><fig position="float" id="F3"><label>Figure 3</label><caption><p><bold>SOV<sub><italic>&#x003b1; </italic></sub>accuracy histogram</bold>. Histogram showing the distribution of SOV<sub><italic>&#x003b1; </italic></sub>across proteins in the test set. We have shown the average case, and the best of the 20 runs which has the highest SOV<sub><italic>&#x003b1;</italic></sub>.</p></caption><graphic xlink:href="1471-2105-8-S5-S3-3"/></fig><fig position="float" id="F4"><label>Figure 4</label><caption><p><bold>Summary of learning algorithm</bold>. In this figure each large frame represents a problem that needs to be solved. On the left, we start with an intractably large problem. At each iteration, we pick a subset of the large problem to work on, solve it approximately using an SVM formulation, and use the resulting solution to expand the subset of constraints we are working with.</p></caption><graphic xlink:href="1471-2105-8-S5-S3-4"/></fig><fig position="float" id="F5"><label>Figure 5</label><caption><p><bold>Algorithm for iterative contraint based optimization</bold>. Algorithm for iterative constraint based optimization.</p></caption><graphic xlink:href="1471-2105-8-S5-S3-5"/></fig><table-wrap position="float" id="T1"><label>Table 1</label><caption><p>Number of parameters used for various protein structure predictors.</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="center" colspan="3">Number of Predictor Parameters</td></tr></thead><tbody><tr><td align="center"><bold>Category</bold></td><td align="center"><bold>Predictor</bold></td><td align="center"><bold>Number of Parameters</bold></td></tr><tr><td colspan="3"><hr></hr></td></tr><tr><td align="center">Neural Net</td><td align="center">PHD [9]</td><td align="center">&#x02265; 10,000</td></tr><tr><td align="center">Neural Net</td><td align="center">SSPro [23]</td><td align="center">1400&#x02013;2900</td></tr><tr><td align="center">Neural Net</td><td align="center">Riis &#x00026; Krogh [10]</td><td align="center">311&#x02013;600</td></tr><tr><td align="center">GOR + Linear Discrimination</td><td align="center">DSC [6]</td><td align="center">1000</td></tr><tr><td align="center">HMM</td><td align="center">Martin et al. [15]</td><td align="center">471</td></tr><tr><td align="center">HM-SVM</td><td align="center">this paper (alpha only)</td><td align="center">302</td></tr></tbody></table></table-wrap><table-wrap position="float" id="T2"><label>Table 2</label><caption><p>Performance of our algorithm on all-alpha protein structure prediction.</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="center" colspan="6">SOV<sub><italic>&#x003b1; </italic></sub>and Q<sub><italic>&#x003b1; </italic></sub>Results</td></tr></thead><tbody><tr><td align="center">Description</td><td align="center">SOV<sub><italic>&#x003b1; </italic></sub>(%) (train)</td><td align="center">SOV<sub><italic>&#x003b1; </italic></sub>(%) (test)</td><td align="center">Q<sub><italic>&#x003b1; </italic></sub>(%) (train)</td><td align="center">Q<sub><italic>&#x003b1; </italic></sub>(%) (test)</td><td align="center">Training time (s)</td></tr><tr><td colspan="6"><hr></hr></td></tr><tr><td align="center">Best run for SOV<sub><italic>&#x003b1;</italic></sub></td><td align="center">76.4</td><td align="center">75.1</td><td align="center">79.6</td><td align="center">78.6</td><td align="center">123</td></tr><tr><td align="center">Average of 20 runs</td><td align="center">75.1</td><td align="center">73.4</td><td align="center">79.1</td><td align="center">77.6</td><td align="center">162</td></tr><tr><td align="center">Standard deviation of 20 runs</td><td align="center">1.0</td><td align="center">1.4</td><td align="center">0.6</td><td align="center">0.9</td><td align="center">30</td></tr></tbody></table></table-wrap><table-wrap position="float" id="T3"><label>Table 3</label><caption><p>Summary of basic features that are considered.</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="center" colspan="3">Features considered by predictor</td></tr></thead><tbody><tr><td align="center">Name</td><td align="center">Number of features</td><td align="left">Description</td></tr><tr><td colspan="3"><hr></hr></td></tr><tr><td align="center"><italic>A</italic></td><td align="center">1</td><td align="left">Penalty for very short coil</td></tr><tr><td align="center"><italic>B</italic></td><td align="center">1</td><td align="left">Penalty for short coil</td></tr><tr><td align="center"><italic>H</italic><sub>
                              <italic>R</italic>
                           </sub></td><td align="center">20</td><td align="left">Energy of residue <italic>R </italic>in a helix</td></tr><tr><td align="center"><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M56" name="1471-2105-8-S5-S3-i15" overflow="scroll">
                              <mml:semantics definitionURL="" encoding="">
                                 <mml:mrow>
                                    <mml:msubsup>
                                       <mml:mi>C</mml:mi>
                                       <mml:mi>R</mml:mi>
                                       <mml:mi>i</mml:mi>
                                    </mml:msubsup>
                                 </mml:mrow>
                                 <mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaacqWGdbWqdaqhaaWcbaGaemOuaifabaGaemyAaKgaaaaa@3070@</mml:annotation>
                              </mml:semantics>
                           </mml:math></inline-formula></td><td align="center">140</td><td align="left">Energy of residue <italic>R </italic>at position i relative to C-cap</td></tr><tr><td align="center"><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M57" name="1471-2105-8-S5-S3-i16" overflow="scroll">
                              <mml:semantics definitionURL="" encoding="">
                                 <mml:mrow>
                                    <mml:msubsup>
                                       <mml:mi>N</mml:mi>
                                       <mml:mi>R</mml:mi>
                                       <mml:mi>i</mml:mi>
                                    </mml:msubsup>
                                 </mml:mrow>
                                 <mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaacqWGobGtdaqhaaWcbaGaemOuaifabaGaemyAaKgaaaaa@3086@</mml:annotation>
                              </mml:semantics>
                           </mml:math></inline-formula></td><td align="center">140</td><td align="left">Energy of residue <italic>R </italic>at position i relative to N-cap</td></tr><tr><td colspan="3"><hr></hr></td></tr><tr><td align="center">Total</td><td align="center">302</td><td></td></tr></tbody></table><table-wrap-foot><p>Each of these features corresponds to a parameter that is learned by our algorithm.</p></table-wrap-foot></table-wrap><table-wrap position="float" id="T4"><label>Table 4</label><caption><p>Sets of features that are emitted by transitions in the FSM.</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="center" colspan="3">Sets of features emitted by FSM transition</td></tr></thead><tbody><tr><td align="center">Label</td><td align="left">Features</td><td align="left">Description</td></tr><tr><td colspan="3"><hr></hr></td></tr><tr><td align="center">#0</td><td align="left">0</td><td align="left">Coil defined as zero-energy</td></tr><tr><td align="center">#1</td><td align="left"><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M58" name="1471-2105-8-S5-S3-i17" overflow="scroll">
                              <mml:semantics definitionURL="" encoding="">
                                 <mml:mrow>
                                    <mml:mstyle displaystyle="true">
                                       <mml:msubsup>
                                          <mml:mo>&#x02211;</mml:mo>
                                          <mml:mrow>
                                             <mml:mi>i</mml:mi>
                                             <mml:mo>=</mml:mo>
                                             <mml:mo>&#x02212;</mml:mo>
                                             <mml:mn>3</mml:mn>
                                          </mml:mrow>
                                          <mml:mrow>
                                             <mml:mo>+</mml:mo>
                                             <mml:mn>3</mml:mn>
                                          </mml:mrow>
                                       </mml:msubsup>
                                       <mml:mrow>
                                          <mml:msubsup>
                                             <mml:mi>C</mml:mi>
                                             <mml:mrow>
                                                <mml:msub>
                                                   <mml:mi>R</mml:mi>
                                                   <mml:mrow>
                                                      <mml:mi>n</mml:mi>
                                                      <mml:mo>+</mml:mo>
                                                      <mml:mi>i</mml:mi>
                                                      <mml:mo>&#x02212;</mml:mo>
                                                      <mml:mn>1</mml:mn>
                                                   </mml:mrow>
                                                </mml:msub>
                                             </mml:mrow>
                                             <mml:mrow>
                                                <mml:mi>i</mml:mi>
                                                <mml:mo>&#x02212;</mml:mo>
                                                <mml:mn>1</mml:mn>
                                             </mml:mrow>
                                          </mml:msubsup>
                                       </mml:mrow>
                                    </mml:mstyle>
                                 </mml:mrow>
                                 <mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaadaaeWaqaaiabdoeadnaaDaaaleaacqWGsbGudaWgaaadbaGaemOBa4Maey4kaSIaemyAaKMaeyOeI0IaeGymaedabeaaaSqaaiabdMgaPjabgkHiTiabigdaXaaaaeaacqWGPbqAcqGH9aqpcqGHsislcqaIZaWmaeaacqGHRaWkcqaIZaWma0GaeyyeIuoaaaa@4013@</mml:annotation>
                              </mml:semantics>
                           </mml:math></inline-formula></td><td align="left">End of helix processing (C-cap)</td></tr><tr><td align="center">#2</td><td align="left"><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M59" name="1471-2105-8-S5-S3-i18" overflow="scroll">
                              <mml:semantics definitionURL="" encoding="">
                                 <mml:mrow>
                                    <mml:msub>
                                       <mml:mi>H</mml:mi>
                                       <mml:mrow>
                                          <mml:msub>
                                             <mml:mi>R</mml:mi>
                                             <mml:mi>n</mml:mi>
                                          </mml:msub>
                                       </mml:mrow>
                                    </mml:msub>
                                    <mml:mo>+</mml:mo>
                                    <mml:mstyle displaystyle="true">
                                       <mml:msubsup>
                                          <mml:mo>&#x02211;</mml:mo>
                                          <mml:mrow>
                                             <mml:mi>i</mml:mi>
                                             <mml:mo>=</mml:mo>
                                             <mml:mo>&#x02212;</mml:mo>
                                             <mml:mn>3</mml:mn>
                                          </mml:mrow>
                                          <mml:mrow>
                                             <mml:mo>+</mml:mo>
                                             <mml:mn>3</mml:mn>
                                          </mml:mrow>
                                       </mml:msubsup>
                                       <mml:mrow>
                                          <mml:msubsup>
                                             <mml:mi>N</mml:mi>
                                             <mml:mrow>
                                                <mml:msub>
                                                   <mml:mi>R</mml:mi>
                                                   <mml:mrow>
                                                      <mml:mi>n</mml:mi>
                                                      <mml:mo>+</mml:mo>
                                                      <mml:mi>i</mml:mi>
                                                      <mml:mo>&#x02212;</mml:mo>
                                                      <mml:mn>1</mml:mn>
                                                   </mml:mrow>
                                                </mml:msub>
                                             </mml:mrow>
                                             <mml:mrow>
                                                <mml:mi>i</mml:mi>
                                                <mml:mo>&#x02212;</mml:mo>
                                                <mml:mn>1</mml:mn>
                                             </mml:mrow>
                                          </mml:msubsup>
                                       </mml:mrow>
                                    </mml:mstyle>
                                 </mml:mrow>
                                 <mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaacqWGibasdaWgaaWcbaGaemOuai1aaSbaaWqaaiabd6gaUbqabaaaleqaaOGaey4kaSYaaabmaeaacqWGobGtdaqhaaWcbaGaemOuai1aaSbaaWqaaiabd6gaUjabgUcaRiabdMgaPjabgkHiTiabigdaXaqabaaaleaacqWGPbqAcqGHsislcqaIXaqmaaaabaGaemyAaKMaeyypa0JaeyOeI0IaeG4mamdabaGaey4kaSIaeG4mamdaniabggHiLdaaaa@4524@</mml:annotation>
                              </mml:semantics>
                           </mml:math></inline-formula></td><td align="left">Start of helix processing (N-cap)</td></tr><tr><td align="center">#3</td><td align="left"><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M60" name="1471-2105-8-S5-S3-i19" overflow="scroll">
                              <mml:semantics definitionURL="" encoding="">
                                 <mml:mrow>
                                    <mml:msub>
                                       <mml:mi>H</mml:mi>
                                       <mml:mrow>
                                          <mml:msub>
                                             <mml:mi>R</mml:mi>
                                             <mml:mi>n</mml:mi>
                                          </mml:msub>
                                       </mml:mrow>
                                    </mml:msub>
                                 </mml:mrow>
                                 <mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaacqWGibasdaWgaaWcbaGaemOuai1aaSbaaWqaaiabd6gaUbqabaaaleqaaaaa@30BB@</mml:annotation>
                              </mml:semantics>
                           </mml:math></inline-formula></td><td align="left">Normal helix residue</td></tr><tr><td align="center">#4</td><td align="left"><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M61" name="1471-2105-8-S5-S3-i19" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mrow><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaacqWGibasdaWgaaWcbaGaemOuai1aaSbaaWqaaiabd6gaUbqabaaaleqaaaaa@30BB@</mml:annotation></mml:semantics></mml:math></inline-formula> + <italic>A</italic></td><td align="left">Helix after very short coil</td></tr><tr><td align="center">#5</td><td align="left"><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M62" name="1471-2105-8-S5-S3-i19" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mrow><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaacqWGibasdaWgaaWcbaGaemOuai1aaSbaaWqaaiabd6gaUbqabaaaleqaaaaa@30BB@</mml:annotation></mml:semantics></mml:math></inline-formula> + <italic>B</italic></td><td align="left">Helix after short coil</td></tr></tbody></table><table-wrap-foot><p><italic>R</italic><sub><italic>i </italic></sub>denotes the residue at position <italic>i </italic>in the protein, and <italic>n </italic>is the current position of the FSM.</p></table-wrap-foot></table-wrap></sec></back></article>